Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Metrics\(Powerful Toolkit For Measure\)
- NOTE
<pre>Metrics最早是在Java的另外一个开源项目dropwizard中使用，主要是为了提供对应用程序各种关
键指标的度量手段以及报告方式，由于其内部的度量手段科学合理，源码本身可扩展性极强，
现在已经被广泛使用在各大框架平台中，比如我们常见的Kafka，Apache Storm，Spring Cloud等。
dropwizard项目的官方地址为：https://www.dropwizard.io/en/latest/感兴趣的读者也可以了解一下。
在本章中我们将会全面详细的了解什么是Metrics，如何使用Metrics，在Metrics中有哪些组件
（Metric，MetricsRegister，Report，Metric常见的插件等），Metrics会对我们的应用程序带来
哪些监控度量方面的便利等。由于其内部实现源码非常优雅，因此在本章中我们也会讲述Metrics的部分核心源码，
让读者更加深入Metrics的原理，方便根据自己的业务需求进行二次开发。</pre>

## Metrics快速入门
- NOTE
<pre>Metrics是一个非常轻量级的框架，其核心jar包只有134KB的大小，在使用的过程中只需要通过Maven对其进行引入即可。

如何监控度量应用程序？
在将应用程序部署到生产环境中之后，我们一般会很想知道某些重要指标的数据，
比如当前有多少用户在线、有哪些服务的调用出现了问题、某个服务接口被调用了多少次、
业务受理的成功率（或失败率）、服务接口的平均响应时长等。当然我们有多种办法实现这样的功能，
比如以下几种：
▪ 实时更新所要监控的数据并将其记录在数据库中：这种方式毫无疑问可以实现我们想要的性能数据，
但是可能会对数据库形成一定的压力，并且让业务程序与性能监控程序产生耦合。
▪ 将所要监控的数据写入日志：通过输出日志的方式记录所要监控的数据，然后由另外的程序
（Apache Flume、LogStash、splunk等）采集日志文本，经过分析之后存入关系型数据库中。
这种解决方案目前应用比较广泛，因为它做到了真正的无侵入性，应用程序根本不知道监控程序的存在，
只需要根据一定的规范打印日志即可。
▪ 采用JMX的方式监控性能数据：将需要监控的性能数据封装成符合JMX规范的MBean，这样我们就
可以借助于JMX客户端程序（比如jconsole、jvisualvm）进行远程查看。
▪ 提供嵌入式的RESTful接口：如同JMX监控的方式一样，我们可以提供RESTful服务接口，将需要特别
监控的数据封装成Resource，对外提供HTTP的访问。
▪ 借助于Metrics工具集：收集性能监控数据，然后将数据交给Reporter进行不同形式的展现，甚至还
可以将Metrics收集到的数据与目前比较强大的运维监控工具Ganglia、Graphite等结合在一起。
虽然Metrics收集数据也需要在应用程序中侵入性能数据收集的相关代码，但是这种方式基本上
不会影响业务程序的运行，因为它对度量数据的report完全是以异步的方式进行的。

Metrics提供了非常强大的性能数据收集方式，并且在Metrics内部集成了CSV、JMX、Log、Console
四大Reporter，除此之外，Reporter是一个非常易于扩展的接口，使用者可以通过自定义Reporter的
形式将Metrics收集到的数据展示（存储）在任何地方。
Metrics的官网地址：https:// metrics.dropwizard.io/3.1.0/

</pre>

## 五大Metric
> leftSide=`true`

- NOTE
<pre>首先，在应用程序中植入Metric用于收集系统运行时产生的性能数据，各个Metric被注册在
MetricRegistry中，Reporter从MetricRegistry中获取各个Metric的数据，然后进行输出或存储
等操作。Metrics为我们提供了五大可用的Metric组件。</pre>

### Meter
- NOTE
<pre>Meter主要用来测量一组事件发生的速率，比如，我们可以用它来度量某个服务接口被调用的频率，
甚至可以用它来度量某些网络操作的吞吐量。</pre>

### Gauge
- NOTE
<pre>Gauge是最简单的Metric类型，它只返回一个Value值，比如，它可以用来查看某个关键队列在
某个时刻的size，或者用来查看当前网站的在线人数等。虽然Gauge的作用比较简单，但是其在实际
中的应用却是比较广泛的，为此，Metrics提供了5种不同的Gauge实现。

1. Simple Gauge详解
Simple Gauge就像它的名字所表明的那样，非常简单，仅会返回需要我们关注的值。比如，
在block queue中，多线程同时对其进行pop及add操作，如果想要知道在某个时刻该队列的
size是多少，则可以借助于Simple Gauge来进行实现。

2. JMX Attribute Gauge详解
除了在应用程序中可以定义很多符合JMX标准的MBean之外，JDK还为我们提供了非常多的MBean
，用于诊断JVM的一些运行指标数据。如果想要获取JVM的MBean，则需要借助于jconsole、
jvisualvm、jprofiler这样的工具；如果想要远程查看，那么还必须打开JMX服务端口。
-Djava.rmi.server.hostname=192.168.1.1 -Dcom.sun.management.jmxremote.port=12345
-Dcom.sun.management.jmxremote.ssl=false
-Dcom.sun.management.jmxremote.authenticate=false
那么有没有某种方式，可以将MBean提供的数据直接输出到日志或者控制台上呢？答案是肯定的。
比如，如果想要查看当前应用程序堆区与非堆区的使用大小情况，就可以借助于
JmxAttributeGauge来很好地完成。

3. Ratio Gauge详解
Ratio Gauge可用于创建两个数字之间的某种比率，比如业务受理的成功率或失败率等。通常，
我们在处理订单的时候，由于用户的原因可能会进行取消订单的操作，中断整个订单执行的流程。
对于这样的数据统计，Ratio Gauge将会是一个非常好的选择。

4. Cached Gauge详解
有时，我们想要获取的Gauge value对实时性的要求并没有那么高，比如我们想要从数据库中获取用户
的状态，或者计算某个队列的size，这样我们就没有必要每次都计算它的真实Value，而是将计算结果
暂时缓存一段时间，等设置的时间过期之后再重新获取。

5. Derivative Gauge详解
Derivative Gauge允许从某个Gauge value中获取特定的属性和值，比如，我们将Cache的Stats作为
一个Metric，Stats中包含了非常多的属性，但是我们只需要其中的一两个，比如Cache未命中率、
Cache加载异常统计等，此时我们就可以借助Derivative Gauge来派生这样的功能。




</pre>

### Counter
- NOTE
<pre>我们使用一个简单的Gauge获取了queue的当前size作为一个Metric，这种方式看起来能够正常运行，
但是调用相关API的方式获取value会影响到其他线程使用queue本身的性能，这种度量方式也会对
应用程序带来性能上的侵入损耗。
Counter Metric提供了一个64位数字的递增和递减的解决方案，可以帮我们解决在度量的过程中
性能侵入的问题。</pre>

### Histogram
- NOTE
<pre>直方图（Histogram）又称质量分布图，是一种统计报告图，由一系列高度不等的纵向条纹或线段表示
数据分布的情况。一般用横轴表示数据类型，纵轴表示分布情况。
直方图是数值数据分布的精确图形表示，这是一个对连续变量（定量变量）的概率分布的估计，并且
由卡尔·皮尔逊（Karl Pearson）首先引入，它是一种条形图。构建直方图的步骤是，首先对值的
范围进行分段，即将整个值的范围分成一系列的间隔，然后计算每个间隔中有多少个值。这些值
通常被指定为连续的、不重叠的变量间隔。间隔必须相邻，并且通常是（但不是必需的）相等的大小。
Metrics还为我们提供了Histogram的数据统计方式，本节将为大家介绍如何通过Histogram Metric
进行度量数据的统计。假设系统为用户提供了商品搜索功能，如果想要统计每一次用户通过关键词
的搜索会产生多少条结果条目，那么我们需要特别关注搜索的结果，因此需要将其纳入度量中来。
</pre>

### Timer
- NOTE
<pre>Timer是基于Histogram和Meter的一种针对度量数据进行统计的方式，主要用于统计业务方法的
响应速度，简单来说就是调用某个业务接口共花费了多少时间。</pre>

## Reporter
> leftSide=`true`

- NOTE
<pre>我们接触到了如何将Metrics工具收集到的数据进行输出（通过控制台的方式进行输出），
Metrics内置了4种输出度量报告的形式，同时，我们也可以看到某些第三方平台和框架也
开发了对应的Reporter插件，比如将Metrics度量数据发布到Ganglia、Graphite等监控工具中，
当然如果你非常熟悉某个监控工具，那么你甚至可以自定义属于自己的Reporter，然后进行展示。
</pre>

### ConsoleReporter
- NOTE
<pre>ConsoleReporter正如其名字一样，用于将Metric度量数据进行控制台输出。当然这种Reporter
主要应用于开发阶段，并不推荐将其直接使用在生产环境中进行度量数据的汇总输出。
在构造ConsoleReporter的时候，我们采用它所提供的静态方法forRegistry()对其进行构造。
这也不难理解，Reporter的数据主要来源于MetricRegistry中的各种Metric，
调用了forRegistry方法之后，事实上会返回一个Builder对象，该对象提供了很多用于控制信息的
输出方式和方法参数。本节简单列举几个进行说明即可，其余的则可以采用默认的方式。
1. convertRatesTo
Rate即速率的意思，当通过convertRatesTo()方法传递某个时间单位时，速率的统计单位就会
以指定的单位进行输出（比如，每秒、每分、每毫秒），其实在Gauge和Counter中，关于速率的
单位设定将会被忽略，因为它们不进行任何关于速率的统计度量，虽然Histogram是一种统计方式，
但是它同样不会用到关于速率的单位，因此我们的设定也会被忽略。
所以在之前学习过的五大Metric中，只有Meter和Timer会用到Rate的时间单位设置。

2. convertDurationsTo
Durations即时长的意思，当通过convertDurationsTo方法传递某个时间单位时，时长/耗时的
单位就会以我们设定的时间单位进行输出，比如，执行某个方法花费了多长时间，除了Timer会用
到时长的时间单位之外，其他的四个Metric都不会使用到这个单位设定。

3. reporter的start
当reporter的所有参数通过Builder对象设置完毕之后，我们需要对其进行start调用。在start方法中，
第一个参数是报告输出的时间间隔，第二个参数是时间间隔的单位。
比如reporter.start(10, TimeUnit.SECONDS)：每10秒进行一次报告的输出。

4. 其他
一般情况下其他的参数只需要保持默认即可，这并不会影响我们对Metrics的使用，但有些时候，
如果想要做一些特殊化的制定，那就需要了解Builder提供的额外方法了。Builder提供的额外
方法具体如下：
▪ shutdownExecutorOnStop：通过Reporter的stop方法来停止内置的线程服务，默认为true。
▪ scheduleOn： 给定自定义的线程服务替换内置的线程服务。
▪ outputTo：控制台输出方式，默认为System.out，当然你也可以将其替换为文件的PrintStream，
将其输出到某个文件中，甚至输出到某个网路套接字中。
▪ formattedFor（Locale locale）：主要用于设置Locale相关。
▪ withClock：主要用于控制时间（毫秒）相关。
▪ formattedFor(TimeZone timeZone)：主要用于设置时区相关。
▪ filter：如果不想让MetricRegistry中的某个Metric在该Reporter中输出，则可以传入一个
MetricFilter接口实现，至此之后关于该Metric的度量信息将不会出现在Reporter的输出中。
▪ disabledMetricAttributes：屏蔽某个Metric属性，比如，如果不想让Timer输出太多的信息，
则可以通过该方法对某个属性进行屏蔽。


</pre>

### LogReporter
- NOTE
<pre>控制台报告不建议用于生产环境，因为它除了在某种情况下会引起线程死锁的问题（System.out），
还会导致程序的性能受到影响，Metrics官方充分地考虑到了这一点，因此其提供了LogReporter的
方式，在生产环境中使用这种方式其实是一种不错的选择，但是相较于Console Reporter，
使用LogReporter的时候会相对麻烦一些。
1. 引入log的依赖
2. 配置log appender
</pre>

### JMXReporter
- NOTE
<pre>除了使用Log相关的Reporter替代Console Reporter之外，将Metric的度量报告通过JMX MBean的
方式展现出来，其实是一种更好的方式，尤其是在提供在线服务的平台、服务中，比如Apache Kafka
的Metric信息就提供了非常详细的JMX接口暴露，这样的话，如果我们想要远程监控获取某些性能
指标，就非常容易了。JMXReporter与Console Reporter、Logger Reporter不一样的是，
其内部并未提供定时线程服务，因此我们在对其进行start操作时，无需给定任何时间间隔及时间单位
，JMXReporter更多的操作其实是将Metric Registry中的所有Metric定义成MBean，并且注册
到ObjectNameFactory中。</pre>

### CsvReporter
- NOTE
<pre>CsvReporter与logger reporter比较类似，也是将所有的度量信息输出到文件之中，但是它会以表格
的形式展示，可读性更好一些，日后如果想要将这些CSV中的数据导入到数据库中也是非常方便的，
甚至还可以基于Excel打开CSV文件进行二次统计、过滤等操作，如果想要将度量数据生成到CSV
文件中，则可以考虑利用这种方式进行操作。</pre>

## Metrics Plugins
- NOTE
<pre>Metrics之所以如此受欢迎，是它除了提供了一套度量指标的标准之外，其源代码层次分明、
可扩展性强也是一个非常重要的因素。在GitHub上，与Metrics插件相关的项目非常多，
远远超过了Metrics内核本身的代码量，本节也将详细介绍其中的两个插件，以方便大家在工作
中遇到好的Metrics插件时可以快速地引入，并直接使用。</pre>

### Health Check
- NOTE
<pre>通常情况下，在我们的应用程序部署到服务器之后，首先会做一次冒烟测试（测试应用程序的基本功能，
以确保其能够提供正常的服务），有些人将其称之为release的Health Check，当然，程序release
之后需要可持续的在线服务，Health Check同样也是非常重要的，这非常有助于运维人员被动式
地收到告警，及时解决问题，本节就将会学习Metrics Health Check插件的使用方法。
Health check的依赖并没有包含在Metrics核心源码中，需要我们手动引入。
&lt;dependency&gt;
    &lt;groupId&gt;io.dropwizard.metrics&lt;/groupId&gt;
    &lt;artifactId&gt;metrics-healthchecks&lt;/artifactId&gt;
    &lt;version&gt;3.2.6&lt;/version&gt;
&lt;/dependency&gt;




</pre>

#### 死锁检查
- NOTE
<pre>1. 死锁检查
在使用Health Check这一插件的时候，我们需要定义HealthCheckRegistry，但是这个Registry
与MetricRegistry完全不是一个概念，虽然它们都是Registry，前者主要用于注册HealthCheck的子类，
后者主要用于注册各种不同类型的Metric。首先需要将你所关心的检查内容（HealthCheck子类）
注册至HealthCheckRegistry中，然后将HealthCheck所有子类的运行结果作为一个Gauge注册至
Metric Registry中。
由于线程死锁检查需要依赖Metrics JVM插件，因此这里还需要引入对Metrics JVM的依赖：
&lt;dependency&gt;
    &lt;groupId&gt;io.dropwizard.metrics&lt;/groupId&gt;
    &lt;artifactId&gt;metrics-jvm&lt;/artifactId&gt;
    &lt;version&gt;3.2.6&lt;/version&gt;
&lt;/dependency&gt;</pre>

#### 自定义Health Check
- NOTE
<pre>虽然引入了Health Check插件包的依赖，但事实上，该包中并未提供多少Health Check的相关实现，
如果想要对自己的应用程序做相关Health Check也是非常容易的，比如，如果想要查看RESTful接口
是否能够正常提供服务，那么通过拓展Health Check就可以轻而易举地做到。</pre>

#### Health Check Set
- NOTE
<pre>分别针对线程死锁，以及RESTful API进行了健康检查，如果想要将所有的健康检查都纳入Metrics 
Reporter中，就像纳入了所有的Metric一样，我们又该如何操作呢？其实在Metrics中，这种需求
非常容易得到满足，在HealthCheckSetTest中，我们就将前面的健康检查都纳入了Console Reporter中。</pre>

### JVM Instrumentation
- NOTE
<pre>JVM Instrumentation插件，提供了大量的针对Java虚拟机的相关信息度量，并且这里面所有的
Metric都是以Metric Set的形式出现的，当前版本的Metrics-JVM插件大致提供了如下的Metric Set：
▪ BufferPoolMetricSet：JVM缓冲池相关。
▪ CachedThreadStatesGaugeSet：与JVM线程信息相关的CachedGauge。
▪ ClassLoadingGaugeSet：类加载器相关。
▪ FileDescriptorRatioGauge：文件句柄或者文件描述符的使用率。
▪ GarbageCollectorMetricSet：JVM垃圾回收器相关的MetricSet。
▪ MemoryUsageGaugeSet：JVM内存使用情况的MetricSet。
▪ ThreadStatesGaugeSet：线程状态的MetricSet。</pre>

## 深入Metrics源码
> leftSide=`true`

- NOTE
<pre>Metrics之所以被大量应用在一些开源项目和平台中，除了它严谨科学的指标数据度量方法，最重要的
还要得益于它优雅的软件设计哲学，正如我们见到过太多基于Junit衍生出来的很多TDD
（测试驱动开发）、BDD（行为驱动开发）、DDT（数据驱动测试）工具一样，
比如Mockito、EasyMock、PowerMock、Cucumber、Jbehave、Concordion这些针对
测试类的工具框架，都可以非常容易地与Junit结合在一起使用，究其原因就是因为Junit软件架构
虽然小巧，但是可扩展性却极强。
因此笔者个人极力推荐读者应该学习和研究一下Metrics的源码，当然其中有些数学算法的实现，
如果不是很熟悉统计学的知识，看起来就会感觉不是很容易理解，但是这些都不重要，我们主要
了解它的实现原理，以及能将软件设计中比较好的地方为我们所用即可。</pre>

### MetricRegistry如何工作
- NOTE
<pre>首先，我们来看一下MetricRegistry，所谓MetricRegistry，从字面意思来看，就是一个存放Metric
的注册表，事实上它的作用也正是如此，在MetricRegistry的内部维护了一个ConcurrentMap。
protected ConcurrentMap&lt;String, Metric&gt; buildMap() {
        return new ConcurrentHashMap&lt;String, Metric&gt;();
    }
当我们调用注册方法的时候，对应的Metric会被加入到注册表中：
</pre>

### Reporter如何工作
- NOTE
<pre>在Metrics中，除了JmxReporter之外，其他的几个内置Reporter都具备定时输出注册表中对应
Metric度量指标数据的功能。另外，Reporter也是在其他开源项目中被扩展最多的组件之一，
比如，将Metric中的数据写入数据库，或者中间件，发送至远程的某个TCP端口等，都可以借助于
自定义Reporter来实现。</pre>

## SharedMetricRegistries
- NOTE
<pre>在你的应用程序中可能不止需要一个Metric Registry进行Metric的注册，如果将一些互不相干的
Metric注册到一个Metric Registry中，那么对应的reporter在输出的时候就需要进行一些复杂的
过滤操作，最好的一种方式就是将它们分别放在不同的Metric Registry中，这种方式又会引入另一个
新的问题，那就是多个Metric Registry的管理。
Metrics官方已经提前想到了这一点，并且提供了一个全局的单实例，以及线程安全的类用于维护
和管理多个Metric Registry，即SharedMetricRegistries，由于它的使用比较简单，
将不再赘述，读者若有需要可以自行去官方网站查看文档，或者直接使用该API进行操作。</pre>
