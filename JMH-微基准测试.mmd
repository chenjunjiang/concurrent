Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# JMH
- NOTE
<pre>JMH是Java Micro Benchmark Harness的简写，是专门用于代码微基准测试的工具集（toolkit）。
JMH是由实现Java虚拟机的团队开发的，因此他们非常清楚开发者所编写的代码在虚拟机中将会如何执行。
由于现代JVM已经变得越来越智能，在Java文件的编译阶段、类的加载阶段，以及运行阶段都可能进行了不同程度的优化，
因此开发者编写的代码在运行中未必会像自己所预期的那样具有相同的性能体现，
JVM的开发者为了让普通开发者能够了解自己所编写的代码运行的情况，JMH便因此而生。</pre>

## @Benchmark
- NOTE
<pre>与Junit4.x版本需要使用@Test注解标记单元测试方法一样，JMH对基准测试的方法需要使用@Benchmark注解进行标记，
否则方法将被视为普通方法，并且不会对其执行基准测试。如果一个类中没有任何基准测试方法（被@Benchmark标记的方法），
那么对其进行基准测试则会出现异常。</pre>

## Warmup以及Measurement
> leftSide=`true`

- NOTE
<pre>Warmup可直译为“预热”的意思，在JMH中，Warmup所做的就是在基准测试代码正式度量之前，
先对其进行预热，使得代码的执行是经历过了类的早期优化、JVM运行期编译、JIT优化之后的最终状态，
从而能够获得代码真实的性能数据。Measurement则是真正的度量操作，在每一轮的度量中，
所有的度量数据会被纳入统计之中（预热数据不会纳入统计之中）。

通过类注解的方式设置的全局Measurement和Warmup参数是可以被基准测试方法通过同样的方式覆盖的，
但是通过Options进行的全局设置则无法被覆盖，也就是说，通过Options设置的参数会应用于所有的基准测试方法且无法被修改（当然不同的版本可能会存在差异）。</pre>

### 设置全局的Warmup和Measurement
- NOTE
<pre>设置全局的Warmup和Measurement执行批次，既可以通过构造Options时设置，
也可以在对应的class上用相应的注解进行设置。</pre>

#### 构造Options时设置Warmup和Measurement的执行批次

#### 使用@Measurement和@Warmup注解进行设置

###  在基准测试方法上设置Warmup和Measurement

### Warmup和Measurement的输出信息解释
- NOTE
<pre># JMH version: 1.19 -- JMH版本
# VM version: JDK 1.8.0_162, VM 25.162-b12
# VM invoker: D:\Java\jdk1.8.0_162\jre\bin\java.exe
-- JVM运行时指定的参数
# VM options: -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:/jmh.hprof -javaagent:D:\IntelliJ IDEA 2019.3.3\lib\idea_rt.jar=60135:D:\IntelliJ IDEA 2019.3.3\bin -Dfile.encoding=UTF-8
-- 热身的批次是10，每一个批次都会不断的调用基准方法，每一个批次的执行时间为1秒
# Warmup: 10 iterations, 1 s each
-- 真正度量的批次为10，这10个批次的调用产生的性能数据才会真正地纳入统计，每一个批次的度量执行时间为1秒
# Measurement: 10 iterations, 1 s each
-- 每一个批次的超时时间为10分钟
# Timeout: 10 min per iteration
-- 执行基准测试的线程数量
# Threads: 1 thread, will synchronize iterations
-- Benchmark的Mode，这里表示一个批次的平均时间
# Benchmark mode: Average time, time/op
# Benchmark: com.chenjj.concurrent.jmh.ArrayListVSLinkedListWithJmh.arrayListAdd

# Run progress: 0.00% complete, ETA 00:00:40
# Fork: 1 of 1
-- 执行10个批次的热身，并输出每个批次调用基准方法的平均耗时
# Warmup Iteration   1: 0.032 us/op
# Warmup Iteration   2: 0.017 us/op
# Warmup Iteration   3: 0.051 us/op
# Warmup Iteration   4: 0.016 us/op
# Warmup Iteration   5: 0.018 us/op
# Warmup Iteration   6: 0.016 us/op
# Warmup Iteration   7: 0.016 us/op
# Warmup Iteration   8: 0.015 us/op
# Warmup Iteration   9: 0.015 us/op
# Warmup Iteration  10: 0.022 us/op
-- 执行10个批次的度量，并输出每个批次调用基准方法的平均耗时
Iteration   1: 0.014 us/op
Iteration   2: 0.012 us/op
Iteration   3: 0.012 us/op
Iteration   4: 0.012 us/op
Iteration   5: 0.029 us/op
Iteration   6: 0.036 us/op
Iteration   7: 0.015 us/op
Iteration   8: 0.015 us/op
Iteration   9: 0.010 us/op
Iteration  10: 0.010 us/op

-- 该基准方法执行完后的最终结果
Result &quot;com.chenjj.concurrent.jmh.ArrayListVSLinkedListWithJmh.arrayListAdd&quot;:
  0.016 ±(99.9%) 0.013 us/op [Average]
  (min, avg, max) = (0.010, 0.016, 0.036), stdev = 0.009
  CI (99.9%): [0.003, 0.030] (assumes normal distribution)


# JMH version: 1.19
# VM version: JDK 1.8.0_162, VM 25.162-b12
# VM invoker: D:\Java\jdk1.8.0_162\jre\bin\java.exe
# VM options: -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:/jmh.hprof -javaagent:D:\IntelliJ IDEA 2019.3.3\lib\idea_rt.jar=60135:D:\IntelliJ IDEA 2019.3.3\bin -Dfile.encoding=UTF-8
# Warmup: 10 iterations, 1 s each
# Measurement: 10 iterations, 1 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: com.chenjj.concurrent.jmh.ArrayListVSLinkedListWithJmh.linkedListAdd

# Run progress: 50.00% complete, ETA 00:00:22
# Fork: 1 of 1
# Warmup Iteration   1: 0.591 us/op
# Warmup Iteration   2: 0.591 us/op
# Warmup Iteration   3: 0.093 us/op
# Warmup Iteration   4: 0.354 us/op
# Warmup Iteration   5: 0.091 us/op
# Warmup Iteration   6: 0.314 us/op
# Warmup Iteration   7: 0.410 us/op
# Warmup Iteration   8: 0.083 us/op
# Warmup Iteration   9: 0.327 us/op
# Warmup Iteration  10: 0.085 us/op
Iteration   1: 0.328 us/op
Iteration   2: 0.081 us/op
Iteration   3: 0.343 us/op
Iteration   4: 0.084 us/op
Iteration   5: 0.366 us/op
Iteration   6: 0.085 us/op
Iteration   7: 0.355 us/op
Iteration   8: 0.081 us/op
Iteration   9: 0.330 us/op
Iteration  10: 0.081 us/op


Result &quot;com.chenjj.concurrent.jmh.ArrayListVSLinkedListWithJmh.linkedListAdd&quot;:
  0.213 ±(99.9%) 0.209 us/op [Average]
  (min, avg, max) = (0.081, 0.213, 0.366), stdev = 0.139
  CI (99.9%): [0.004, 0.423] (assumes normal distribution)


# Run complete. Total time: 00:01:26

Benchmark                                   Mode  Cnt  Score   Error  Units
ArrayListVSLinkedListWithJmh.arrayListAdd   avgt   10  0.016 ± 0.013  us/op
ArrayListVSLinkedListWithJmh.linkedListAdd  avgt   10  0.213 ± 0.209  us/op</pre>

## 四大BenchmarkMode
> leftSide=`true`

- NOTE
<pre>JMH使用@BenchmarkMode这个注解来声明使用哪一种模式来运行，
JMH为我们提供了四种运行模式，当然它还允许若干个模式同时存在，
在我看来，Mode无非就是统计基准测试数据的不同方式和纬度口径。
BenchmarkMode既可以在class上进行注解设置，也可以在基准方法上进行注解设置，
方法中设置的模式将会覆盖class注解上的设置，同样，在Options中也可以进行设置，
它将会覆盖所有基准方法上的设置。</pre>

### AverageTime
- NOTE
<pre>AverageTime（平均响应时间）模式主要用于输出基准测试方法每调用一次所耗费的时间，
也就是elapsedtime/operation。</pre>

### Throughput
- NOTE
<pre>Throughput（方法吞吐量）则刚好与AverageTime相反，
它的输出信息表明了在单位时间内可以对该方法调用多少次。</pre>

### SampleTime
- NOTE
<pre>SampleTime（时间采样）的方式是指采用一种抽样的方式来统计基准测试方法的性能结果，
与我们常见的Histogram图（直方图）几乎是一样的，它会收集所有的性能数据，
并且将其分布在不同的区间中。</pre>

### SingleShotTime
- NOTE
<pre>SingleShotTime主要可用来进行冷测试，不论是Warmup还是Measurement，
在每一个批次中基准测试方法只会被执行一次，一般情况下，我们会将Warmup的批次设置为0。
Single Shot Time也是采用Histogram的方式进行统计的。</pre>

### 多Mode以及All
- NOTE
<pre>我们除了对某个基准测试方法设置上述四个模式中的一个之外，
还可以为其设置多个模式的方式运行基准测试方法，如果你愿意，甚至可以设置全部的Mode。</pre>

## OutputTimeUnit
- NOTE
<pre>OutputTimeUnit提供了统计结果输出时的时间单位，比如，调用一次该方法将会耗费多少个单位时间，
或者在单位时间内对该方法进行了多少次的调用，同样，OutputTimeUnit既可以设置在class上，
也可以设置在method上，还可以在Options中进行设置，它们的覆盖次序与BenchmarkMode一致</pre>

## 三大State
> leftSide=`true`

- NOTE
<pre>在JMH中，有三大State分别对应于Scope的三个枚举值。
▪ Benchmark
▪ Thread
▪ Group
这三个Scope是非常重要的State</pre>

### Scope\.Thread
- NOTE
<pre>Thread独享的State
所谓线程独享的State是指，每一个运行基准测试方法的线程都会持有一个独立的对象实例，
该实例既可能是作为基准测试方法参数传入的，也可能是运行基准方法所在的宿主class，
将State设置为Scope.Thread一般主要是针对非线程安全的类。</pre>

### Scope\.Benchmark
- NOTE
<pre>Thread共享的State
有时候，我们需要测试在多线程的情况下某个类被不同线程操作时的性能，
比如，多线程访问某个共享数据时，我们需要让多个线程使用同一个实例才可以。
因此JMH提供了多线程共享的一种状态Scope.Benchmark</pre>

### Scope\.Group
- NOTE
<pre>线程组共享的State
正常情况下，我们所编写的基准测试方法都会被JMH框架根据方法名的字典顺序排序后按照顺序逐个
地调用执行，因此不存在两个方法同时运行的情况，
如果想要测试某个共享数据或共享资源在多线程的情况下同时被读写的行为，是没有办法进行的，
比如，在多线程高并发的环境中，多个线程同时对一个ConcurrentHashMap进行读写。
通过上面这段文字可以简单地归纳出我们的诉求：
第一，是在多线程情况下的单个实例；
第二，允许一个以上的基准测试方法并发并行地运行。
Scope.Group可以帮助我们实现这一点。</pre>

## @Param
- NOTE
<pre>JMH为我们提供了一个@Param的注解，它使得参数可配置，
也就是说一个参数在每一次的基准测试时都会有不同的值与之对应。</pre>

## JMH的测试套件（Fixture）
> leftSide=`true`


### Setup以及TearDown
- NOTE
<pre>JMH提供了两个注解@Setup和@TearDown用于套件测试，
其中@Setup会在每一个基准测试方法执行前被调用，通常用于资源的初始化，
@TearDown则会在基准测试方法被执行之后被调用，通常可用于资源的回收清理工作</pre>

### Level
- NOTE
<pre>在默认情况下，Setup和TearDown会在一个基准方法的所有批次执行前后分别执行，
如果需要在每一个批次或者每一次基准方法调用执行的前后执行对应的套件方法，
则需要通过Level对@Setup和@TearDown进行简单的配置：
Level.Trail：Setup和TearDown默认的配置，该套件方法会在每一个基准测试方法的所有批次执行的前后被执行。
Level.Iteration：由于我们可以设置Warmup和Measurement，
因此每一个基准测试方法都会被执行若干个批次，
如果想要在每一个批次执行的前后调用套件方法，则可以将Level设置为Iteration。
Level.Invocation：将Level设置为Invocation意味着在每一个批次的度量(Measurement)过程中，
每一次对基准方法的调用前后都会执行套件方法。
需要注意的是，套件方法的执行也会产生CPU时间的消耗，
但是JMH并不会将这部分时间纳入基准方法的统计之中，这一点更进一步地说明了JMH的严谨之处。</pre>

## CompilerControl
- NOTE
<pre>做基准测试的时候可以通过CompilerControl来禁止JVM运行期动态编译和优化。
如果你想在自己的应用程序中杜绝JVM运行期的优化，
那么我们可以通过如下的方式来实现（虽然这种情况我们并不推荐）。
▪ 通过编写程序的方式禁止JVM运行期动态编译和优化java.lang.Compiler.disable();
▪ 在启动JVM时增加参数 -Djava.compiler=NONE。</pre>

## 编写正确的微基准测试
> leftSide=`true`

- NOTE
<pre>虽然JMH可以帮我们更好地了解我们所编写的代码，
但是如果我们所编写的JMH基准测试方法本身就有问题，
那么就会很难起到指导的作用，甚至还会可能会产生误导。</pre>

### 避免DCE（Dead Code Elimination）
