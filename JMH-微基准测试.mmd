Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# JMH
- NOTE
<pre>JMH是Java Micro Benchmark Harness的简写，是专门用于代码微基准测试的工具集（toolkit）。
JMH是由实现Java虚拟机的团队开发的，因此他们非常清楚开发者所编写的代码在虚拟机中将会如何执行。
由于现代JVM已经变得越来越智能，在Java文件的编译阶段、类的加载阶段，以及运行阶段都可能进行了不同程度的优化，
因此开发者编写的代码在运行中未必会像自己所预期的那样具有相同的性能体现，
JVM的开发者为了让普通开发者能够了解自己所编写的代码运行的情况，JMH便因此而生。

官方的例子就是最好的文档，可以参考。
https://github.com/openjdk/jmh/tree/master/jmh-samples/src/main/java/org/openjdk/jmh/samples

我自己的dubbo-source-analyze项目里面也有JMH例子。
Netty的测试用例中也用到了JMH。
https://github.com/netty/netty/blob/4.1/microbench/src/main/java/io/netty/microbench/concurrent/FastThreadLocalSlowPathBenchmark.java</pre>

## @Benchmark
- NOTE
<pre>与Junit4.x版本需要使用@Test注解标记单元测试方法一样，JMH对基准测试的方法需要使用@Benchmark注解进行标记，
否则方法将被视为普通方法，并且不会对其执行基准测试。如果一个类中没有任何基准测试方法（被@Benchmark标记的方法），
那么对其进行基准测试则会出现异常。</pre>

## Warmup以及Measurement
> leftSide=`true`

- NOTE
<pre>Warmup可直译为“预热”的意思，在JMH中，Warmup所做的就是在基准测试代码正式度量之前，
先对其进行预热，使得代码的执行是经历过了类的早期优化、JVM运行期编译、JIT优化之后的最终状态，
从而能够获得代码真实的性能数据。Measurement则是真正的度量操作，在每一轮的度量中，
所有的度量数据会被纳入统计之中（预热数据不会纳入统计之中）。

通过类注解的方式设置的全局Measurement和Warmup参数是可以被基准测试方法通过同样的方式覆盖的，
但是通过Options进行的全局设置则无法被覆盖，也就是说，通过Options设置的参数会应用于所有的基准测试方法且无法被修改（当然不同的版本可能会存在差异）。</pre>

### 设置全局的Warmup和Measurement
- NOTE
<pre>设置全局的Warmup和Measurement执行批次，既可以通过构造Options时设置，
也可以在对应的class上用相应的注解进行设置。</pre>

#### 构造Options时设置Warmup和Measurement的执行批次

#### 使用@Measurement和@Warmup注解进行设置

###  在基准测试方法上设置Warmup和Measurement

### Warmup和Measurement的输出信息解释
- NOTE
<pre># JMH version: 1.19 -- JMH版本
# VM version: JDK 1.8.0_162, VM 25.162-b12
# VM invoker: D:\Java\jdk1.8.0_162\jre\bin\java.exe
-- JVM运行时指定的参数
# VM options: -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:/jmh.hprof -javaagent:D:\IntelliJ IDEA 2019.3.3\lib\idea_rt.jar=60135:D:\IntelliJ IDEA 2019.3.3\bin -Dfile.encoding=UTF-8
-- 热身的批次是10，每一个批次都会不断的调用基准方法，每一个批次的执行时间为1秒
# Warmup: 10 iterations, 1 s each
-- 真正度量的批次为10，这10个批次的调用产生的性能数据才会真正地纳入统计，每一个批次的度量执行时间为1秒
# Measurement: 10 iterations, 1 s each
-- 每一个批次的超时时间为10分钟
# Timeout: 10 min per iteration
-- 执行基准测试的线程数量
# Threads: 1 thread, will synchronize iterations
-- Benchmark的Mode，这里表示一个批次的平均时间
# Benchmark mode: Average time, time/op
# Benchmark: com.chenjj.concurrent.jmh.ArrayListVSLinkedListWithJmh.arrayListAdd

# Run progress: 0.00% complete, ETA 00:00:40
# Fork: 1 of 1
-- 执行10个批次的热身，并输出每个批次调用基准方法的平均耗时
# Warmup Iteration   1: 0.032 us/op
# Warmup Iteration   2: 0.017 us/op
# Warmup Iteration   3: 0.051 us/op
# Warmup Iteration   4: 0.016 us/op
# Warmup Iteration   5: 0.018 us/op
# Warmup Iteration   6: 0.016 us/op
# Warmup Iteration   7: 0.016 us/op
# Warmup Iteration   8: 0.015 us/op
# Warmup Iteration   9: 0.015 us/op
# Warmup Iteration  10: 0.022 us/op
-- 执行10个批次的度量，并输出每个批次调用基准方法的平均耗时
Iteration   1: 0.014 us/op
Iteration   2: 0.012 us/op
Iteration   3: 0.012 us/op
Iteration   4: 0.012 us/op
Iteration   5: 0.029 us/op
Iteration   6: 0.036 us/op
Iteration   7: 0.015 us/op
Iteration   8: 0.015 us/op
Iteration   9: 0.010 us/op
Iteration  10: 0.010 us/op

-- 该基准方法执行完后的最终结果
Result &quot;com.chenjj.concurrent.jmh.ArrayListVSLinkedListWithJmh.arrayListAdd&quot;:
  0.016 ±(99.9%) 0.013 us/op [Average]
  (min, avg, max) = (0.010, 0.016, 0.036), stdev = 0.009
  CI (99.9%): [0.003, 0.030] (assumes normal distribution)


# JMH version: 1.19
# VM version: JDK 1.8.0_162, VM 25.162-b12
# VM invoker: D:\Java\jdk1.8.0_162\jre\bin\java.exe
# VM options: -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:/jmh.hprof -javaagent:D:\IntelliJ IDEA 2019.3.3\lib\idea_rt.jar=60135:D:\IntelliJ IDEA 2019.3.3\bin -Dfile.encoding=UTF-8
# Warmup: 10 iterations, 1 s each
# Measurement: 10 iterations, 1 s each
# Timeout: 10 min per iteration
# Threads: 1 thread, will synchronize iterations
# Benchmark mode: Average time, time/op
# Benchmark: com.chenjj.concurrent.jmh.ArrayListVSLinkedListWithJmh.linkedListAdd

# Run progress: 50.00% complete, ETA 00:00:22
# Fork: 1 of 1
# Warmup Iteration   1: 0.591 us/op
# Warmup Iteration   2: 0.591 us/op
# Warmup Iteration   3: 0.093 us/op
# Warmup Iteration   4: 0.354 us/op
# Warmup Iteration   5: 0.091 us/op
# Warmup Iteration   6: 0.314 us/op
# Warmup Iteration   7: 0.410 us/op
# Warmup Iteration   8: 0.083 us/op
# Warmup Iteration   9: 0.327 us/op
# Warmup Iteration  10: 0.085 us/op
Iteration   1: 0.328 us/op
Iteration   2: 0.081 us/op
Iteration   3: 0.343 us/op
Iteration   4: 0.084 us/op
Iteration   5: 0.366 us/op
Iteration   6: 0.085 us/op
Iteration   7: 0.355 us/op
Iteration   8: 0.081 us/op
Iteration   9: 0.330 us/op
Iteration  10: 0.081 us/op


Result &quot;com.chenjj.concurrent.jmh.ArrayListVSLinkedListWithJmh.linkedListAdd&quot;:
  0.213 ±(99.9%) 0.209 us/op [Average]
  (min, avg, max) = (0.081, 0.213, 0.366), stdev = 0.139
  CI (99.9%): [0.004, 0.423] (assumes normal distribution)


# Run complete. Total time: 00:01:26

Benchmark                                   Mode  Cnt  Score   Error  Units
ArrayListVSLinkedListWithJmh.arrayListAdd   avgt   10  0.016 ± 0.013  us/op
ArrayListVSLinkedListWithJmh.linkedListAdd  avgt   10  0.213 ± 0.209  us/op</pre>

## 四大BenchmarkMode
> leftSide=`true`

- NOTE
<pre>JMH使用@BenchmarkMode这个注解来声明使用哪一种模式来运行，
JMH为我们提供了四种运行模式，当然它还允许若干个模式同时存在，
在我看来，Mode无非就是统计基准测试数据的不同方式和纬度口径。
BenchmarkMode既可以在class上进行注解设置，也可以在基准方法上进行注解设置，
方法中设置的模式将会覆盖class注解上的设置，同样，在Options中也可以进行设置，
它将会覆盖所有基准方法上的设置。</pre>

### AverageTime
- NOTE
<pre>AverageTime（平均响应时间）模式主要用于输出基准测试方法每调用一次所耗费的时间，
也就是elapsedtime/operation。</pre>

### Throughput
- NOTE
<pre>Throughput（方法吞吐量）则刚好与AverageTime相反，
它的输出信息表明了在单位时间内可以对该方法调用多少次。</pre>

### SampleTime
- NOTE
<pre>SampleTime（时间采样）的方式是指采用一种抽样的方式来统计基准测试方法的性能结果，
与我们常见的Histogram图（直方图）几乎是一样的，它会收集所有的性能数据，
并且将其分布在不同的区间中。</pre>

### SingleShotTime
- NOTE
<pre>SingleShotTime主要可用来进行冷测试，不论是Warmup还是Measurement，
在每一个批次中基准测试方法只会被执行一次，一般情况下，我们会将Warmup的批次设置为0。
Single Shot Time也是采用Histogram的方式进行统计的。</pre>

### 多Mode以及All
- NOTE
<pre>我们除了对某个基准测试方法设置上述四个模式中的一个之外，
还可以为其设置多个模式的方式运行基准测试方法，如果你愿意，甚至可以设置全部的Mode。</pre>

## OutputTimeUnit
- NOTE
<pre>OutputTimeUnit提供了统计结果输出时的时间单位，比如，调用一次该方法将会耗费多少个单位时间，
或者在单位时间内对该方法进行了多少次的调用，同样，OutputTimeUnit既可以设置在class上，
也可以设置在method上，还可以在Options中进行设置，它们的覆盖次序与BenchmarkMode一致</pre>

## 三大State
> leftSide=`true`

- NOTE
<pre>在JMH中，有三大State分别对应于Scope的三个枚举值。
▪ Benchmark
▪ Thread
▪ Group
这三个Scope是非常重要的State</pre>

### Scope\.Thread
- NOTE
<pre>Thread独享的State
所谓线程独享的State是指，每一个运行基准测试方法的线程都会持有一个独立的对象实例，
该实例既可能是作为基准测试方法参数传入的，也可能是运行基准方法所在的宿主class，
将State设置为Scope.Thread一般主要是针对非线程安全的类。</pre>

### Scope\.Benchmark
- NOTE
<pre>Thread共享的State
有时候，我们需要测试在多线程的情况下某个类被不同线程操作时的性能，
比如，多线程访问某个共享数据时，我们需要让多个线程使用同一个实例才可以。
因此JMH提供了多线程共享的一种状态Scope.Benchmark。</pre>

### Scope\.Group
- NOTE
<pre>线程组共享的State
正常情况下，我们所编写的基准测试方法都会被JMH框架根据方法名的字典顺序排序后按照顺序逐个
地调用执行，因此不存在两个方法同时运行的情况，
如果想要测试某个共享数据或共享资源在多线程的情况下同时被读写的行为，是没有办法进行的，
比如，在多线程高并发的环境中，多个线程同时对一个ConcurrentHashMap进行读写。
通过上面这段文字可以简单地归纳出我们的诉求：
第一，是在多线程情况下的单个实例；
第二，允许一个以上的基准测试方法并发并行地运行。
Scope.Group可以帮助我们实现这一点。例子见：JMHStateScopeGroup
同一个线程组的线程才会共享一个对象实例，要保证多个基准测试方法同时运行，方法上修饰的线程组
名称必须要一样。例子见：SynchronizedVsLockVsAtomicInteger</pre>

## @Param
- NOTE
<pre>JMH为我们提供了一个@Param的注解，它使得参数可配置，
也就是说一个参数在每一次的基准测试时都会有不同的值与之对应。</pre>

## JMH的测试套件（Fixture）
> leftSide=`true`


### Setup以及TearDown
- NOTE
<pre>JMH提供了两个注解@Setup和@TearDown用于套件测试，
其中@Setup会在每一个基准测试方法执行前被调用，通常用于资源的初始化，
@TearDown则会在基准测试方法被执行之后被调用，通常可用于资源的回收清理工作</pre>

### Level
- NOTE
<pre>在默认情况下，Setup和TearDown会在一个基准方法的所有批次执行前后分别执行，
如果需要在每一个批次或者每一次基准方法调用执行的前后执行对应的套件方法，
则需要通过Level对@Setup和@TearDown进行简单的配置：
Level.Trail：Setup和TearDown默认的配置，该套件方法会在每一个基准测试方法的所有批次执行的前后被执行。
Level.Iteration：由于我们可以设置Warmup和Measurement，
因此每一个基准测试方法都会被执行若干个批次，
如果想要在每一个批次执行的前后调用套件方法，则可以将Level设置为Iteration。
Level.Invocation：将Level设置为Invocation意味着在每一个批次的度量(Measurement)过程中，
每一次对基准方法的调用前后都会执行套件方法。
需要注意的是，套件方法的执行也会产生CPU时间的消耗，
但是JMH并不会将这部分时间纳入基准方法的统计之中，这一点更进一步地说明了JMH的严谨之处。</pre>

## CompilerControl
- NOTE
<pre>做基准测试的时候可以通过CompilerControl来禁止JVM运行期动态编译和优化。
如果你想在自己的应用程序中杜绝JVM运行期的优化，
那么我们可以通过如下的方式来实现（虽然这种情况我们并不推荐）。
▪ 通过编写程序的方式禁止JVM运行期动态编译和优化java.lang.Compiler.disable();
▪ 在启动JVM时增加参数 -Djava.compiler=NONE。</pre>

## 编写正确的微基准测试
> leftSide=`true`

- NOTE
<pre>虽然JMH可以帮我们更好地了解我们所编写的代码，
但是如果我们所编写的JMH基准测试方法本身就有问题，
那么就会很难起到指导的作用，甚至还会可能会产生误导。

现代的Java虚拟机已经发展得越来越智能了，它在类的早期编译阶段、
加载阶段以及后期的运行时都可以为我们的代码进行相关的优化，
比如Dead Code的擦除、常量的折叠，还有循环的打开，甚至是进程Profiler的优化，
等等，因此要掌握如何编写良好的微基准测试方法，首先我们要知道什么样的基准测试代码是有问题的。</pre>

### 避免DCE（Dead Code Elimination）
- NOTE
<pre>所谓Dead Code Elimination是指JVM为我们擦去了一些上下文无关，
甚至经过计算之后确定压根不会用到的代码，比如下面这样的代码片段：
public void test(){
   int x = 10;
   int y = 10;
   int z = x+y;
}
我们在test方法中分别定义了x和y，并且经过相加运算得到了z，
但是在该方法的下文中再也没有其他地方使用到z（既没有对z进行返回，也没有对其进行二次使用，
z甚至不是一个全局的变量），JVM很有可能会将test()方法当作一个空的方法来看待，
也就是说会擦除对x、y的定义，以及计算z的相关代码。</pre>

### 使用Blackhole
- NOTE
<pre>假设在基准测试方法中，需要将两个计算结果作为返回值，那么我们该如何去做呢？
我们第一时间想到的可能是将结果存放到某个数组或者容器当中作为返回值，
但是这种对数组或者容器的操作会对性能统计造成干扰，
因为对数组或者容器的写操作也是需要花费一定的CPU时间的。
JMH提供了一个称为Blackhole的类，可以在不作任何返回的情况下避免Dead Code的发生，
Blackhole直译为“黑洞”，与Linux系统下的黑洞设备/dev/null非常相似。

Blackhole可以帮助你在无返回值的基准测试方法中避免DC（Dead Code）情况的发生。</pre>

### 避免常量折叠（Constant Folding）
- NOTE
<pre>常量折叠是Java编译器早期的一种优化——编译优化。在javac对源文件进行编译的过程中，
通过词法分析可以发现某些常量是可以被折叠的，也就是可以直接将计算结果存放到声明中，
而不需要在执行阶段再次进行运算。比如：
private final inx x = 10;
private final int y = x*20;
在编译阶段，y的值将被直接赋予200，这就是所谓的常量折叠。</pre>

### 避免循环展开（Loop Unwinding）
- NOTE
<pre>我们在编写JMH代码的时候，除了要避免Dead Code以及减少对常量的引用之外，
还要尽可能地避免或者减少在基准测试方法中出现循环，
因为循环代码在运行阶段（JVM后期优化）极有可能被“痛下杀手”进行相关的优化，
这种优化被称为循环展开（LoopUnwinding）。
比如：
int sum = 0;
for (int i=0;i&lt;100;i++) {
     sum+=i;
}
上面的例子中，sum=sum+i这样的代码会被执行100次，
也就是说，JVM会向CPU发送100次这样的计算指令，这看起来并没有什么，
但是JVM的设计者们会认为这样的方式可以被优化成如下形式（可能）。
int sum = 0;
for (int i=0;i&lt;20;i+=5) {
     sum+=i;
     sum+=i+2;
     sum+=i+3;
     sum+=i+4;
     sum+=i+5;
}
优化后将循环体中的计算指令批量发送给CPU，这种批量的方式可以提高计算的效率，
假设1+2这样的运算执行一次需要1纳秒的CPU时间，那么在一个10次循环的计算中，
我们觉得它可能是10纳秒的CPU时间，但是真实的计算情况可能不足10纳秒甚至更低。</pre>

### Fork用于避免Profile\-guided optimizations
- NOTE
<pre>在开始解释Fork之前，我们想象一下平时是如何进行应用性能测试的，
比如我们要测试一下Redis分别在50、100、200个线程中同时进行共计一亿次的写操作时的响应速度，
一般会怎样做？首先，我们会将Redis库清空，尽可能地保证每一次测试的时候，
不同的测试用例站在同样的起跑线上，比如，服务器内存的大小、服务器磁盘的大小、
服务器CPU的大小等基本上相同，这样的对比才是有意义的，然后根据测试用例对其进行测试，
接着清理Redis服务器资源，使其回到测试之前的状态，最后统计测试结果做出测试报告。

Fork的引入也是考虑到了这个问题，虽然Java支持多线程，但是不支持多进程，
这就导致了所有的代码都在一个进程中运行，相同的代码在不同时刻的执行可能会引入前一阶段
对进程profiler的优化，甚至会混入其他代码profiler优化时的参数，
这很有可能会导致我们所编写的微基准测试出现不准确的问题。</pre>

## 高级用法

### Asymmetric Benchmark
- NOTE
<pre>其实就是State  Scope.Group的应用。</pre>

### Interrupts Benchmark
- NOTE
<pre>有些时候我们想要执行某些容器(比如阻塞队列)的读写操作时可能会引起阻塞，
这种阻塞并不是容器无法保证线程安全问题引起的，而是由JMH框架的机制引起的。

难道我们就没有办法测试高并发容器在线程挂起时的性能了吗？
事实上，JMH的设计者们早就为我们想好了对应的解决方案，
我们可以通过设置Options的timeout来强制让每一个批次的度量超时，
超时的基准测试数据将不会被纳入统计之中，这也是JMH的另外一个严谨之处。

代码示例见：JMHBlocking和JMHTimeout。</pre>

## JMH的Profiler\(分析器\)
> leftSide=`true`

- NOTE
<pre>JMH提供了一些非常有用的Profiler可以帮助我们更加深入地了解基准测试，
甚至还能帮助开发者分析所编写的代码。
CL                     分析执行Beachmark方法时的类加载情况
COMP              通过Standard MBean进行Beachmark方法的JIT编译器分析
GC                    通过Standard MBean进行Beachmark方法的GC分析
HS_CL              HotSpot类加载器通过特定于实现的MBean进行分析
HS_COMP       HotSpot JIT通过特定于实现的MBean进行分析
HS_GC             HotSpot 内存管理器(GC)通过特定于实现的MBean进行分析
HS_RT             通过Implementation-Specific MBean进行 HotSpot 运行时分析
HS_THR          通过Implementation-Specific MBean进行 HotSpot 线程分析
STACK            JVM线程栈信息分析</pre>

### StackProfiler
- NOTE
<pre>StackProfiler不仅可以输出线程堆栈的信息，还能统计程序在执行的过程中线程的状态，
比如RUNNING状态、WAIT状态所占用的百分比等。</pre>

### GcProfiler
- NOTE
<pre>GcProfiler可分析出在基准测试过程中，JVM每个内存空间上的GC情况。</pre>

### ClassLoaderProfiler
- NOTE
<pre>ClassLoaderProfiler可以帮助我们看到在基准方法的执行过程中有多少类被加载和卸载，
但是考虑到在一个类加载器中同一个类只会被加载一次的情况，因此我们需要将Warmup设置为0，
以避免在热身阶段就已经加载了基准测试方法所需的所有类。</pre>

### CompilerProfiler
- NOTE
<pre>CompilerProfiler将会告诉你在代码的执行过程中JIT编译器优化所花费的时间，
我们可以打开verbose模式观察更详细的输出。</pre>
