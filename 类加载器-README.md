# 类加载器

1、类加载过程
   类的加载过程一般分为比较大的三个阶段：加载阶段、连接阶段和初始化阶段。
   加载阶段：
   主要负责查找并且加载类的二进制数据文件，其实就是class文件。将class文件的二进制数据读取到内存中，然后将该字节流所代表的
静态存储结构转换为方法区中运行时的数据结构，并且在堆内存中生成了一个该类的java.lang.Class对象，作为访问方法区数据结构的入口。
类加载的最终产物就是堆内存中的class对象，对同一个ClassLoader来讲，不管某个类被加载多少次，对应堆内存中的class对象始终是同一个。
   连接阶段：连接阶段做的工作比较多，细分的话还可以分为三个阶段：
   a、验证
      主要是确保类文件的正确性，比如class版本，class文件的魔术因子(魔数：这个魔数的作用就是文件标识，用来标识这是一个字节码文件可以被JVM加载运行)是否正确。
   b、准备
      为类的静态变量分配内存，并且为其初始化默认值。
   c、解析
      把类中的符号引用转换为直接引用。
   初始化阶段：
   JVM对类的初始化是使用的延迟机制，当一个类在首次使用的时候才会被初始化，在同一个运行时包下，一个Class只会被初始化一次
(运行时包和类的包是有区别的)。
   在初始化阶段做的最主要的一件事情就是执行<cinit>()方法(cinit是class initialize前面几个字母的简写)，在<cinit>()方法
中所有的静态变量都会被赋予正确的值，也就是在编写代码的时候指定的值。<cinit>()方法是在编译阶段生成的，也就是说它已经包含
在class文件中了，<cinit>()包含了所有静态变量的赋值动作和静态语句块的执行代码，编译器收集的顺序是由执行语句在源文件中
的出现顺序所决定的。另外<cinit>()方法与类的构造函数不同，它不需要显示的调用父类的构造器，虚拟机会保证父类的<cinit>()
方法最先执行，因此父类的静态变量总是能够得到优先赋值。虽然说Java编译器会帮助class生产<cinit>()方法，但是该方法并不是总
会生成的，比如某个类中既没有静态代码块，也没有静态变量，那么它就没有生成<cinit>()方法的必要了，接口中同样也是如此，
由于接口天生不能定义静态代码块，因此只有当接口中有变量的初始化操作时才会生成<cinit>()方法。

2、类的主动使用和被动使用
   JVM虚拟机规范规定了，每个类或接口被Java程序首次主动使用时才会对其初始化。
   JVM同时规范了以下6种主动使用类的场景：
   a、通过new关键字会导致类的初始化。
   b、访问类的静态变量，包括读取和更新会导致类的初始化。
   c、访问类的静态方法，会导致类的初始化。
   d、对某个类进行反射操作，会导致类的初始化。
   e、初始化子类会导致父类的初始化。注意：通过子类使用父类的静态变量只会导致父类的初始化，子类则不会被初始化。
   f、启动类：也就是执行main函数所在的类会导致该类的初始化。
   除了上述6种情况，其余的都称为被动使用，不会导致类的加载和初始化。
   a、构造某个类的数组时并不会导致该类的初始化:
   public static void main(String[] args) {
           Simple[] simples = new Simple[10];
           System.out.println(simples.length);
   }
   Simple在这里是被动使用，不要被前面的new关键字误导，该操作只不过是在堆内存中开辟了一段连续的地址空间。
   b、引用类的静态常量不会导致类的初始化，见GlobalConstants。
  
3、JVM内置三大类加载器
   不同的类加载器负责将不同的类加载到JVM内存中，并且它们之间严格遵守父委托机制。
   (1) 根类加载器
   又称Bootstrap类加载器，该类加载器是最为顶层的加载器，其没有任何父加载器，由C++编写，主要负责Java核心类库的加载 ，可以通过
-Xbootclasspath来指定根加载器的加载路径。根加载器的加载路径可以通过sun.boot.class.path这个系统属性获得。
   (2) 扩展类加载器
   扩展类加载器的父加载器是根加载器，它主要用于加载JAVA_HOME下的jre\lib\ext目录里面的类库。
扩展类加载器的加载路径可以通过java.ext.dirs这个系统属性获得。
   (3) 系统类加载器
   系统类加载器是一种常见的类加载器，其负责加载classpath下的类库资源。系统类加载器的父加载器是扩展类加载器，同时它也是
自定义类加载器的默认父加载器。系统类加载器的加载路径一般通过-classpath或者-cp指定，同样也可以通过系统属性java.class.path
进行获取。

4、自定义类加载器
   所有的自定义类加载器都是ClassLoader的直接子类或者间接子类，java.lang.ClassLoader是一个抽象类，它里面并没有抽象方法，
但是有findClass方法，务必实现该方法，否则会抛出ClassNotFoundException。

5、双亲委托机制
   又称为父委托机制，当一个类加载器被调用了loadClass之后，它并不会直接将其加载，而是先交给当前类加载器的父加载器尝试
加载直到最顶层的父加载器，然后再依次向下进行加载。加载逻辑可以查看源码：ClassLoader的loadClass(String name, boolean resolve)方法

6、破坏双亲委托机制
   JDK提供的双亲委托机制并非一个强制性的模型，我们可以对其进行灵活发挥破坏这种委托机制，比如我们想要在程序运行时进行某个
模块功能的升级，甚至在不停止服务的前提下增加新的功能，这就是常说的热部署。热部署首先要卸载掉加载该模块所有Class的类加载器，
卸载类加载器会导致所有类的卸载，很显然我们无法对JVM三大内置加载器进行卸载，我们只有通过控制自定义类加载器才能做到。

7、类加载器命名空间
   每一个类加载器实例都有各自的命名空间，命名空间是由该类加载器及其所有父类加载器所构成的，其中父类加载器加载的类对其子类加载器可见，
但是反过来子类加载器加载的类对父类不可见，同一个命名空间中一定不会出现同一个类（全限定名一模一样的类）多个Class对象，
换句话说就是在同一命名空间中只能存在一个Class对象，所以当你听别人说在内存中同一类的Class对象只有一个时其实指的是同一命名空间中，
当然也不排除他压根就不知道这个概念。不同的命名空间中的对象是互不可见的。

8、运行时包
   由同一个类加载器加载的属于相同包的类组成了运行时包。决定两个类是不是属于同一个运行时包，不仅要看它们的包名是否相同，还要看加载它们的类加载器是否相同。
只有属于同一运行时包的类才能互相访问包可见（即默认访问级别）的类和类成员。这样的限制能避免用户自定义的类冒充核心类库的类，去访问核心类库的包可见成员。
   假设用户自己定义了一个类java.lang.Spy，并由用户自定义的类加载器加载，由于java.lang.Spy和核心类库java.lang.*由不同的加载器加载，
它们属于不同的运行时包，所以java.lang.Spy不能访问核心类库java.lang包中的包可见成员。

9、初始类加载器
   每一个类在经过ClassLoader的加载后，在JVM中都会有对应的Class实例，如果某个类C被类加载器CL加载，那么CL就被称为C的初始类加载器。
JVM为每一个类加载器维护了一个列表，该列表中记录了将该类加载器作为初始类加载器的所有class，在加载一个类时，JVM使用这些列表来判断
该类是否已经被加载过了，是否需要首次加载。
   根据JVM规范的规定，在类的加载过程中，所有参与类加载的的类记载器，即使没有亲自加载过该类，也都会被标识为该类的初始类加载器，比如
java.lang.String首先经过了BrokerDelegateClassLoader类加载器，依次又经过了系统类加载器、扩展类加载器、
根类加载器，这些类加载器都是java.lang.String的初始化类加载器，JVM会在每一个类加载器维护的列表中添加该
class类型。虽然SimpleClass和java.lang.String由不同的类加载器加载，但是在BrokerDelegateClassLoader类加载器
的class列表中维护了SimpleClass.class和String.class，因此SimpleClass是可以正常访问String的。

10、类的卸载
    JVM规定了一个Class只有在满足下面三个条件的时候才会被GC回收，也就是类被卸载。
    a、该类所有的实例都已经被GC。
    b、加载该类的ClassLoader实例被回收。
    c、该类的class实例没有在其它地方被引用。