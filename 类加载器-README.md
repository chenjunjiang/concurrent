# 类加载器

1、类加载过程
   类的加载过程一般分为比较大的三个阶段：加载阶段、连接阶段和初始化阶段。
   加载阶段：
   主要负责查找并且加载类的二进制数据文件，其实就是class文件。将class文件的二进制数据读取到内存中，然后将该字节流所代表的
静态存储结构转换为方法区中运行时的数据结构，并且在堆内存中生成了一个该类的java.lang.Class对象，作为访问方法区数据结构的入口。
类加载的最终产物就是堆内存中的class对象，对同一个ClassLoader来讲，不管某个类被加载多少次，对应堆内存中的class对象始终是同一个。
   连接阶段：连接阶段做的工作比较多，细分的话还可以分为三个阶段：
   a、验证
      主要是确保类文件的正确性，比如class版本，class文件的魔术因子(魔数：这个魔数的作用就是文件标识，用来标识这是一个字节码文件可以被JVM加载运行)是否正确。
   b、准备
      为类的静态变量分配内存，并且为其初始化默认值。
   c、解析
      把类中的符号引用转换为直接引用。
   初始化阶段：
   JVM对类的初始化是使用的延迟机制，当一个类在首次使用的时候才会被初始化，在同一个运行时包下，一个Class只会被初始化一次
(运行时包和类的包是有区别的)。
   在初始化阶段做的最主要的一件事情就是执行<cinit>()方法(cinit是class initialize前面几个字母的简写)，在<cinit>()方法
中所有的静态变量都会被赋予正确的值，也就是在编写代码的时候指定的值。<cinit>()方法是在编译阶段生成的，也就是说它已经包含
在class文件中了，<cinit>()包含了所有静态变量的赋值动作和静态语句块的执行代码，编译器收集的顺序是由执行语句在源文件中
的出现顺序所决定的。另外<cinit>()方法与类的构造函数不同，它不需要显示的调用父类的构造器，虚拟机会保证父类的<cinit>()
方法最先执行，因此父类的静态变量总是能够得到优先赋值。虽然说Java编译器会帮助class生产<cinit>()方法，但是该方法并不是总
会生成的，比如某个类中既没有静态代码块，也没有静态变量，那么它就没有生成<cinit>()方法的必要了，接口中同样也是如此，
由于接口天生不能定义静态代码块，因此只有当接口中有变量的初始化操作时才会生成<cinit>()方法。

2、类什么时候被加载？
   可以加上虚拟机参数-XX:+TraceClassLoading来跟踪类的加载
   a、定义了main的类，启动main方法时该类会被加载，见ClassLoadMain。
   b、创建类的实例，即new对象的时候。如果只创建父类实例，子类不会被加载；如果创建子类实例，父类也会被加载。见ClassLoadPS
   c、访问类的静态方法。
   d、访问类的静态变量。
   e、Class.forName("xxx")。
   f、classLoader.loadClass("xxx")。 和e的例子见GetCallerClassTest。
   g、构造某个类的数组时会导致该类被加载：
   public static void main(String[] args) {
              Simple[] simples = new Simple[10];
              System.out.println(simples.length);
   }
   h、引用类的静态常量可能会导致类的加载，也可能不会，见ClassLoadMain。
   i、强转的时候会被加载，见ClassLoadPS。
   j、Class clazz = Account.class.getClass(); 获取类的Class对象的时候也会被加载
   注意：在一个类A里面引用了类B，加载类A的时候不一定会加载类B。

2、类什么时候被初始化？ 类的主动使用和被动使用
   JVM虚拟机规范规定了，每个类或接口被Java程序首次主动使用时才会对其初始化。
   JVM同时规范了以下6种主动使用类的场景：
   a、通过new关键字会导致类的初始化。
   b、访问类的静态变量，包括读取和更新会导致类的初始化。
   c、访问类的静态方法，会导致类的初始化。
   d、对某个类进行反射操作，会导致类的初始化。
   e、初始化子类会导致父类的初始化。注意：通过子类使用父类的静态变量只会导致父类的初始化，子类则不会被初始化。
   f、启动类：也就是执行main函数所在的类会导致该类的初始化。
   除了上述6种情况，其余的都称为被动使用，不会导致类的加载和初始化。既然类都被初始化了，那类肯定被加载了。
   a、构造某个类的数组时并不会导致该类的初始化:
   public static void main(String[] args) {
           Simple[] simples = new Simple[10];
           System.out.println(simples.length);
   }
   Simple在这里是被动使用，不要被前面的new关键字误导，该操作只不过是在堆内存中开辟了一段连续的地址空间。
   b、引用类的静态常量可能会导致类的初始化，也可能不会，见GlobalConstants。
  
3、JVM内置三大类加载器
   不同的类加载器负责将不同的类加载到JVM内存中，并且它们之间严格遵守父委托机制。
   (1) 根类加载器
   又称Bootstrap类加载器，该类加载器是最为顶层的加载器，其没有任何父加载器，由C++编写，主要负责Java核心类库(JAVA_HOME下的jre\lib目录里面的类库)的加载，
可以通过-Xbootclasspath来指定根加载器的加载路径。根加载器的加载路径可以通过sun.boot.class.path这个系统属性获得。
   (2) 扩展类加载器
   扩展类加载器的父加载器是根加载器，它主要用于加载JAVA_HOME下的jre\lib\ext目录里面的类库。
扩展类加载器的加载路径可以通过java.ext.dirs这个系统属性获得。
   (3) 系统类加载器
   系统类加载器是一种常见的类加载器，其负责加载classpath下的类库资源。系统类加载器的父加载器是扩展类加载器，同时它也是
自定义类加载器的默认父加载器。系统类加载器的加载路径一般通过-classpath或者-cp指定，同样也可以通过系统属性java.class.path
进行获取。

4、自定义类加载器
   所有的自定义类加载器都是ClassLoader的直接子类或者间接子类，java.lang.ClassLoader是一个抽象类，它里面并没有抽象方法，
但是有findClass方法，务必实现该方法，否则会抛出ClassNotFoundException。

5、双亲委托机制
   又称为父委托机制，当一个类加载器被调用了loadClass之后，它并不会直接将其加载，而是先交给当前类加载器的父加载器尝试
加载直到最顶层的父加载器，然后再依次向下进行加载。加载逻辑可以查看源码：ClassLoader的loadClass(String name, boolean resolve)方法

6、破坏双亲委托机制
   JDK提供的双亲委托机制并非一个强制性的模型，我们可以对其进行灵活发挥破坏这种委托机制，比如我们想要在程序运行时进行某个
模块功能的升级，甚至在不停止服务的前提下增加新的功能，这就是常说的热部署。热部署首先要卸载掉加载该模块所有Class的类加载器，
卸载类加载器会导致所有类的卸载，很显然我们无法对JVM三大内置加载器进行卸载，我们只有通过控制自定义类加载器才能做到。

7、类加载器命名空间
   每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类组成。
   在同一个命名空间中，不会出现类的完整名字(包括类的包名)相同的两个类。
   在不同的命名空间中，有可能会出现类的完整名字(包括类的包名)相同的两个类。
   同一个命名空间内的类是相互可见的。
   子加载器的命名空间包含所有父加载器的命名空间。即子加载器所加载的类能访问到父加载器加载的类，但父加载器所加载的类不能访问子加载器所访问的类
   如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类相互不可见(这一点非常重要)。
   一个类加载器只能加载一个同名类，在Java默认的类加载器层面作了判断，如果已经有了该类，则不再重复加载，如果强行绕过判断并使用自定义类加载器
重复加载（比如调用 defineClass 方法），JVM 将会抛出LinkageError：attempted duplicate class definition for name。
但请注意，我们说同一个类加载器不可以加载两个同名的类，但不同的类加载器是可以加载同名的类的，加载完成之后，这两个类虽然同名，但不是同一个 Class 对象，无法进行转换。
   案例可以查看：ClassLoaderAccessTest.java、NameSpace.java

8、运行时包
   由同一个类加载器加载的属于相同包的类组成了运行时包。决定两个类是不是属于同一个运行时包，不仅要看它们的包名是否相同，还要看加载它们的类加载器是否相同。
只有属于同一运行时包的类才能互相访问包可见（即默认访问级别）的类和类成员。这样的限制能避免用户自定义的类冒充核心类库的类，去访问核心类库的包可见成员。
   假设用户自己定义了一个类java.lang.Spy，并由用户自定义的类加载器加载，由于java.lang.Spy和核心类库java.lang.*由不同的加载器加载，
它们属于不同的运行时包，所以java.lang.Spy不能访问核心类库java.lang包中的包可见成员。

9、初始类加载器
   每一个类在经过ClassLoader的加载后，在JVM中都会有对应的Class实例，如果某个类C被类加载器CL加载，那么CL就被称为C的初始类加载器。
JVM为每一个类加载器维护了一个列表，该列表中记录了将该类加载器作为初始类加载器的所有class，在加载一个类时，JVM使用这些列表来判断
该类是否已经被加载过了，是否需要首次加载。
   根据JVM规范的规定，在类的加载过程中，所有参与类加载的的类记载器，即使没有亲自加载过该类，也都会被标识为该类的初始类加载器，比如
java.lang.String首先经过了BrokerDelegateClassLoader类加载器，依次又经过了系统类加载器、扩展类加载器、
根类加载器，这些类加载器都是java.lang.String的初始化类加载器，JVM会在每一个类加载器维护的列表中添加该
class类型。虽然SimpleClass和java.lang.String由不同的类加载器加载，但是在BrokerDelegateClassLoader类加载器
的class列表中维护了SimpleClass.class和String.class，因此SimpleClass是可以正常访问String的。

10、类的卸载
https://blog.csdn.net/xorxos/article/details/80490240
    JVM规定了一个Class只有在满足下面三个条件的时候才会被GC回收，也就是类被卸载。
    a、该类所有的实例都已经被GC。
    b、加载该类的ClassLoader实例被回收。
    c、该类的class实例没有在其它地方被引用。
    
11、自定义类加载器加载子类
    a、自定义类加载器加载子类的时候，它的父类也会被加载，且加载父类的类加载器也是该自定义类加载器。见ClassLoadPS