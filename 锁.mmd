Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# 锁
- NOTE
<pre>https://tech.meituan.com/2018/11/15/java-lock.html</pre>

## synchronized
- NOTE
<pre>https://www.cnblogs.com/nizuimeiabc1/p/13574530.html​ 
可能在很多人眼里，在java中提到锁、安全性、同步，首先想到的则是java提供的大佬
（synchronized）。那么为什么在多线程下，单单靠一个关键字修饰代码块就可以实现所谓的安全性
呢？可以说是对初学者而言及神奇又强大的存在。也成了大多数初学者百试不爽的良药。
​ 但是在逐渐对java认知的深入，我们认识到synchronized对于jvm来说是一个重量级的锁。
其笨重无比，在如今人们对速度和性能极致要求的现在，现在此时并不能满足性能上的要求。
 诚然SUN公司也认识到了这一点，在Java SE 1.6对synchronized进行了各种优化后，
 有些情况下它就并不那么笨重了。在Java SE 1.6中为了减少获得锁和释放锁带来的性能开销而
 引入偏向锁和轻量级锁。
 
 Java中每一个对象都可以作为锁。具体有如下三种形式：
对于普通同步方法，锁是当前实例对象。
对于静态同步方法，锁是当前类的Class对象。
对于同步代码块，锁是synchronized括号里配置的对象。</pre>

### Java对象头
- NOTE
<pre>​ synchronized用的锁是存在Java对象头里的。所以这里对Java对象头做详细介绍。
​ synchronized用的锁是存在Java对象头里的。所以这里对Java对象头做详细介绍。

对象的内存布局
​ 在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：

对象头（Header）

实例数据（Instance Data）

对齐填充（Padding）

HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode，更精确的叫Identity HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别位32bit和64bit，官方称它位“Mark Word” （标记字段）。对象需要存储的运行时数据很多，其实已经超出了定义的位数。

Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位HotSpot虚拟机中，如果对象处于被锁定状态下，那么Mark Word的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储锁标志位，1bit固定位0，而在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容见表

存储内容	标志位	状态
对象哈希码、对象分代年龄	01	未锁定
指向锁记录的指针	00	轻量级锁定或者叫自旋锁
指向重量级锁的指针	10	膨胀（重量级锁定）
空，不需要记录信息	11	GC标记,准备垃圾回收，CMS回收器用到
偏向线程ID、偏向时间戳、对象分代年龄	01	可偏向，第三位数字是偏向锁标识flag=1

​ 对象头的另外一部分是类型指针（Klass Pointer）。即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身，此外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数据长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的原数组中却无法确定数组的大小。

​ 在运行期间，Mark Word标记字段里存储的数据会随着锁的标志位的变化而变化

Monitor Record
Monitor Record从字面意义上理解为：监视器记录。Monitor Record是线程私有的数据结构，每一个线程都有一个可用Monitor Record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor record关联（对象头的MarkWord中的LockWord指向monitor record的起始地址），同时monitor record中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。如下图所示为Monitor Record的内部结构</pre>

### 锁优化
- NOTE
<pre>高效并发是从JDK 1.5 到 JDK 1.6的一个重要改进，HotSpot虚拟机在这个版本上花费了大量精力
去实现各种锁优化技术，如：适应性自旋（Adaptive Spinning）、锁消除（Lock Eliminate）、
锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）和偏向锁（Biased Locking）等，
这些技术都是为了解决竞争问题，从而提高程序的执行效率。

在Java SE 1.6里Synchronied同步锁，一共有四种状态：无锁、偏向锁、轻量级锁、重量级锁，
它会随着竞争情况逐渐升级。锁可以升级但是不可以降级，目的是为了提供获取锁和释放锁的效率。
锁膨胀方向： 无锁 → 偏向锁 → 轻量级锁 → 重量级锁 （此过程是不可逆的）
</pre>

#### 自旋锁
- NOTE
<pre>引入背景：
大家都知道，在没有加入锁优化时，大佬Synchronized时一个非常“胖大”的家伙。在多线程竞争锁时，
当一个线程获取锁时，它会阻塞所有正在竞争的线程，这样对性能带来了极大的影响。
挂起线程和恢复线程的操作都需要转入内核态中完成，这些操作给系统的并发性能带来了很大的压力。
同时HotSpot团队注意到在很多情况下，共享数据的锁定状态只会持续很短的一段时间，为了这很短的
时间去挂起和恢复阻塞线程并不值得。在如今多处理器环境下，完全可以让另一个没有获取到锁的
线程在门外等待一会（自旋），但不放弃CPU的执行时间。等待持有锁的线程释放锁。
为了让线程等待，我们只需要让线程执行一个忙循环（自旋），这便是自旋锁由来的原因。

自旋锁早在JDK1.4 中就引入了，只是当时默认时关闭的。在JDK 1.6后默认为开启状态。
自旋锁本质上与阻塞并不相同，先不考虑其对多处理器的要求，如果锁占用的时间非常的短，
那么自旋锁的性能会非常的好，相反，其会带来更多的性能开销（因为在线程自旋时，
始终会占用CPU的时间片，如果锁占用的时间太长，那么自旋的线程会白白消耗掉CPU资源）。
因此自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获取到锁，
就应该使用传统的方式去挂起线程了，在JDK定义中，自旋锁默认的自旋次数为10次，
用户可以使用参数-XX:PreBlockSpin来更改。

可是现在又出现了一个问题：如果锁刚好在线程自旋结束的时候释放了，由于线程自旋转超过了限定，此时会被挂起，
那么是不是有点得不偿失，因为我明明都自旋了那么久，眼看能获取锁了，结果被挂起了。要是能多加点自旋次数多好啊。
所以这时候我们需要更加聪明的锁来实现更加灵活的自旋。来提高并发的性能。
（这里则需要自适应自旋锁！）

</pre>

#### 自适应自旋锁
- NOTE
<pre>在JDK 1.6中引入了自适应自旋锁。这就意味着自旋的时间不再固定了，而是由前一次在同一个锁上
的自旋 时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获取过锁，
并且持有锁的线程正在运行中，那么JVM会认为该锁自旋获取到锁的可能性很大，
会自动增加等待时间。比如增加到100此循环。相反，如果对于某个锁，自旋很少成功获取锁。
那再以后要获取这个锁时将可能省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，
JVM对程序的锁的状态预测会越来越准备，JVM也会越来越聪明。</pre>

#### 锁消除
- NOTE
<pre> 锁消除是指虚拟机即时编译器在运行时，对一些代码上做了同步，但被检测到不可能存在共享数据竞争
 的锁进行消除。锁消除的主要判定依据来源于逃逸分析的数据支持。
 意思就是：JVM会判断一段程序中的同步数据明显不会逃逸出去从而被其他线程访问到，
 那JVM就把它们当作栈上数据对待，认为这些数据时线程独有的，不需要加同步。
 此时就会进行锁消除。

当然在实际开发中，我们很清楚的知道那些地方是线程独有的，不需要加同步锁，
但是在Java API中有很多方法都是加了同步的，那么此时JVM会判断这段代码是否需要加锁。
如果数据并不会逃逸，则会进行锁消除。
比如如下操作：在操作String类型数据时，由于String是一个不可变类，对字符串的连接操作总是
通过生成的新的String对象来进行的。因此Javac编译器会对String连接做自动优化，
在JDK 1.5之前会使用StringBuffer对象的连续append()操作，在JDK 1.5及以后的版本中，
会转化为StringBuidler对象的连续append()操作。
public static String test03(String s1, String s2, String s3) {
        String s = s1 + s2 + s3;
        return s;
    }
 众所周知，StringBuffer是安全同步的。但是在上述代码中，JVM判断该段代码并不会逃逸，
 则将该代码带默认为线程独有的资源，则并不需要同步，所以执行了锁消除操作。
 （还有Vector中的各种操作也可实现锁消除。在没有逃逸出数据安全防卫内）</pre>

#### 锁粗化
- NOTE
<pre>原则上，我们都知道在加同步锁时，尽可能的将同步块的作用范围限制到尽量小的范围
（只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变小。
在存在锁同步竞争中，也可以使得等待锁的线程尽早的拿到锁）。
述情况在大多数时候是完美正确的，但是如果存在一系列操作都对同一个对象反复加锁和解锁，
甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要
地性能损失。
public static String test04(String s1, String s2, String s3) {
        StringBuffer sb = new StringBuffer();
        sb.append(s1);
        sb.append(s2);
        sb.append(s3);
        return sb.toString();
    }
在上述连续append()操作中就属于这类情况。JVM会检测到这样一连串地操作都是对同一个对象
加锁，那么JVM会将加锁同步地范围扩展（粗化）到整个一系列操作的 外部，使整个一连串地
append()操作只需要加锁一次就可以了。</pre>

#### 偏向锁
- NOTE
<pre>偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。
在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。
其目标就是在只有一个线程执行同步代码块时能够提高性能。
当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出
同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。
引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的
获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。

偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。
偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有
偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级
锁（标志位为“00”）的状态。
偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：
-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。

下边演示一下偏向锁升级流程(忽略一些细节)：
线程1当前拥有偏向锁对象,线程2是需要竞争到偏向锁。
https://www.cnblogs.com/tiancai/p/9382542.html

1、线程2来竞争锁对象;
2、判断当前对象头是否是偏向锁;
3、判断拥有偏向锁的线程1是否还存在;
4、线程1不存在,直接设置偏向锁标识为0(线程1执行完毕后,不会主动去释放偏向锁);
5、使用cas替换偏向锁线程ID为线程2,锁不升级，仍为偏向锁;
6、线程1仍然存在,暂停线程1；
7、设置锁标志位为00(变为轻量级锁),偏向锁为0;
8、从线程1的空闲monitor record中读取一条,放至线程1的当前monitor record中;
9、更新mark word，将mark word指向线程1中monitor record的指针;
10、继续执行线程1的代码;
11、锁升级为轻量级锁;   
12、线程2自旋来获取锁对象;


上面仍有一个问题，即如何判断线程1已经不存在了?
(1) 线程执行start时，会将自己写入一个thread_list中,这是一个linked结构，有pre和next节点;
(2)线程执行完后,会将自己从thread list中清理掉(源码位置: Threads::remove(this));
因此只需判断thread list中是否存在线程1即可。</pre>

#### 轻量级锁
- NOTE
<pre>是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的
形式尝试获取锁，不会阻塞，从而提高性能。

在线程进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”）
，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象
目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。
拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，
并将Lock Record里的owner指针指向对象的Mark Word。
如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置
为“00”，表示此对象处于轻量级锁定状态。
如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，
如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，
否则说明多个线程竞争锁。
若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程
在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。</pre>

#### 重量级锁
- NOTE
<pre>升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，
此时等待锁的线程都会进入阻塞状态。</pre>

#### 锁的优缺点对比
- NOTE
<pre>偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋
来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。

偏向锁	
优点：
加锁和解锁没有额外的性能消耗，和执行非同步方法相比仅存在纳秒级的差距	
缺点：
如果线程间存在锁竞争，会带来额外的锁撤销的消耗	
适用场景
适用于只有一个线程访问同步块的场景

轻量级锁	
优点：
竞争的线程不会阻塞(使用自旋)，提高了响应速度	
缺点：
如果始终得不到锁竞争的线程，使用自旋会消耗CPU性能
适用场景	
追求响应时间，同步块执行速度非常快

重量级锁	
优点：
线程竞争不适用自旋，不会消耗CPU	
缺点：
线程阻塞，响应时间缓慢，在多线程下，频繁的获取释放锁，会带来巨大的性能消耗	
适用场景
追求吞吐量，同步块执行时间长</pre>

## 乐观锁 VS 悲观锁
> leftSide=`true`

- NOTE
<pre>悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，
确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。

而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候
去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据
成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作
（例如报错或者自动重试）。
乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过
CAS自旋实现的。

悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。
乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</pre>

## 公平锁 VS 非公平锁
> leftSide=`true`

- NOTE
<pre>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程
才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，
等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。

非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。
但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁(这个线程相当于插队了)，
所以非公平锁有可能出现后申请锁的线程先获取锁的场景。
非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，
因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。
缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。

ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），
添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁
NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定
使用公平锁。公平锁与非公平锁的lock()方法唯一的区别就在于公平锁在获取同步状态时多了一个
限制条件：hasQueuedPredecessors()。
再进入hasQueuedPredecessors()，可以看到该方法主要做一件事情：主要是判断当前线程是否位于
同步队列中的第一个。如果是则返回false，否则返回true。
综上，公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。
非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</pre>

## 可重入锁 VS 非可重入锁
- NOTE
<pre>可重入锁又名递归锁，是指同一个线程在外层方法获取锁的时候，再进入该线程的内层方法会自动
获取锁（前提锁对象得是同一个对象或者class），不会因为之前已经获取过还没释放而阻塞。
Java中ReentrantLock和synchronized都是可重入锁，可重入锁的一个优点是可一定程度避免死锁。

我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么
非可重入锁在重复调用同步资源时会出现死锁。
首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status
来计数重入次数，status初始值为0。
当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在
执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取
到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去
获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。
释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。
如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，
然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，
直接将status置为0，将锁释放。</pre>

## 独享锁 VS 共享锁
> leftSide=`true`

- NOTE
<pre>独享锁也叫排他锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，
则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。
JDK中的synchronized和JUC中Lock的实现类就是互斥锁。
共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加
共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。

ReentrantReadWriteLock有两把锁：ReadLock和WriteLock
读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，
因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。

ReentrantLock无论读操作还是写操作，添加的锁都是都是独享锁。</pre>
