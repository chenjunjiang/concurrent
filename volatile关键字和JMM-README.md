# volatile关键字和JMM
   volatile关键字只能修饰类变量(静态变量)和实例变量，对于方法参数、局部变量以及实例常量，类常量不能进行修饰。

1、并发编程的三个重要特性
   原子性、有序性和可见性。
   a、原子性
   所谓原子性是指在一次操或者多次操作中，要么所有的操作全部得到了执行并且不会受到任何因素的干扰而中断，要么所有的操作都不执行。
   多个原子性的操作在一起就不再是原子性操作了。
   简单的读取与赋值操作时原子性的(比如：x=10)，将一个变量赋给另一个变量的操作不是原子性的。
   volatile关键字不保证数据的原子性，synchronized关键字能保证，Lock也能保证，原子类型变量也可以保证原子性。
   
   b、可见性
   可见性是指，当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。
   在多线程环境下，如果某个线程首次读取共享变量，则首先到主内存中获取该变量，然后存入工作内存中，以后只需要在工作内存中读取该变量
即可。同样如果对该变量执行了修改操作，则先将新值写入工作内存中，然后再刷新到主内存中。但是什么时候最新的值会刷新到主内存中是不太确定的。
   Java提供了以下三种方式来保证可见性：
   (1)、使用关键字volatile，当一个变量被volatile关键字修饰时，对于共享资源的读操作会直接在主内存中进行(当然也会缓存到工作内存中，
当其它线程对该共享资源进行了修改，则会导致当前线程在工作内存中的共享资源失败，所以必须从主内存中再次获取)，对于资源的写操作当然是
先修改工作内存，但是修改结束后会立即将其刷新到主内存中。
   (2)、通过synchronized关键字能够保证可见性，synchronized能够保证同一时刻只有一个线程获得锁，加锁时，将清空工作内存中共享变量的值，
从而使用共享变量是需要从主内存中重新读取最新的值然后执行同步方法，并且还会确保锁在释放之前，会将变量的修改刷新到主内存中。
   (3)、通过JUC提供的显示锁Lock也能保证可见性，Lock的lock方法能够保证在同一个时刻只有一个线程获得锁然后执行同步方法，并且会确保在
锁释放(Lock的unlock方法)之前会将对变量的修改刷新到主内存中。
   
   c、有序性
   所谓有序性是指程序代码在执行过程中的先后顺序。由于Java在编译期以及运行期的优化，导致了代码的执行顺序未必就是开发者编写
代码时的顺序，这种情况就是我们通常所说的指令重排序。
   当然对指令的重排序要严格遵守指令之间的数据依赖关系，并不是可以任意进行重排序的。
   虽然很多硬件都会为了优化做一些重排，但在单线程情况下，无论怎样的重排序最终都会保证程序执行结果和代码顺序执行的结果完全一致，这就是as-if-serial语义，
所有硬件优化的前提都是必须遵守as-if-serial语义，这样单线程的有序性就天然存在了。但是在多线程情况下，如果有序性得不到保证，那么很有可能会出现问题，
比如：
private boolean initialized = false;
private Context context;
public Context load(){
    if(!initialized){
       context = loadContext();
       initialized = true;
    }
    return context;
}
上述代码在单线程下无论怎么重排序，比如context = loadContext();的执行被重排序到了initialized = true;之后，最终返回给
使用者的context都是可用的。如果在多线程情况下，那么就会出问题了，比如一个线程首先判断的到initialized = false，因此准备
执行context的加载，但是由于重排序它二话不说先执行了initialized = true，那么如果此时第二个线程也执行load方法，发现
initialized = true了，则直接返回的context可能是一个还未被加载成功的context，那么程序运行过程中就会出现问题。
   Java提供了三种方式保证有序性：
   (1)、使用volatile关键字来保证有序性。
   (2)、使用synchronized关键字来保证有序性。synchronized通过排他锁的方式就保证了同一时间内，被synchronized修饰的代码是单线程执行的。
单线程的有序性天然存在。
   (3)、使用显示锁Lock来保证有序性。
   
2、happens-before原则
   Java的内存模型具备一些天生的有序性规则，不需要任何同步手段就能够保证有序性，这个规则被称为happens-before原则。如果两个操作的执行次序无法
从happens-before原则推导出来，那么它们就无法保证有序性，也就是说虚拟机或处理器可以随意对它们进行重排序处理。
   a、程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作(这句话的意思看起来是程序按编写的顺序来执行，
但是虚拟机还是可能会对程序代码的指令进行重排序，只要确保在一个线程内最终的结果和代码顺序执行的结果一致即可)；
   b、锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作(意思是无论在单线程还是多线程环境下，如果同一个锁是锁定状态，那么必须
对其执行释放锁操作之后才能继续进行lock操作)；
   c、volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作；
   d、传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C；
   e、线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作；
   f、线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生；
   g、线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行；
   h、对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始；
   
3、volatile关键字的语义
   a、保证不同线程之间对共享变量操作时可见性，也就是说当一个线程修改volatile修饰的变量，另一个线程会立即看到最新的值。
   b、禁止对指令进行重排序。直接禁止JVM和处理器对volatile关键字修饰的指令重排序，但是对于volatile前后无依赖关系的指令则可以随便
怎么排序。
   