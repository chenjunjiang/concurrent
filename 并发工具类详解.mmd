Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# 工具类
- NOTE
<pre>所有例子都在项目的utils包下。</pre>

## CountDownLatch
- NOTE
<pre>CountDownLatch（Count Down Latch，直译为倒计数门阀），
它的作用就与其名字所表达的意思一样，是指有一个门阀在等待着倒计数，
直到计数器为0的时候才能打开，当然我们可以在门阀等待打开的时候指定超时时间。</pre>

## CyclicBarrier
> leftSide=`true`

- NOTE
<pre>CyclicBarrier（循环屏障），它也是一个同步助手工具，
它允许多个线程在执行完相应的操作之后彼此等待共同到达一个障点（barrier point）。
CyclicBarrier也非常适合用于某个串行化任务被分拆成若干个并行执行的子任务，
当所有的子任务都执行结束之后再继续接下来的工作。从这一点来看，
Cyclic Barrier与CountDownLatch非常类似，但是它们之间的运行方式以及原理还是存在着比较大的差异的，
并且CyclicBarrier所能支持的功能CountDownLatch是不具备的。
比如，CyclicBarrier可以被重复使用，而CountDownLatch当计数器为0的时候就无法再次利用。

CyclicBarrier的另一个很好的特性是可以被循环使用，
也就是说当其内部的计数器为0之后还可以在接下来的使用中重置而无须重新定义一个新的。

1）当一个线程由于在执行CyclicBarrier的await方法而进入阻塞状态时，
这个时候对该线程执行中断操作会导致CyclicBarrier被broken。
2）被broken的CyclicBarrier此时已经不能再直接使用了，
如果想要使用就必须使用reset方法对其重置。
3）如果有其他线程此时也由于执行了await方法而进入阻塞状态，
那么该线程会被唤醒并且抛出BrokenBarrierException异常。
通过CyclicBarrier的await方法源码可以很清晰的了解上述过程。

CyclicBarrier VS. CountDownLatch
▪ CyclicBarrier内部的计数器count是可被重置的，进而使得CyclicBarrier也可被重复使用，而CoundDownLatch则不能。
▪ CyclicBarrier是由Lock和Condition实现的，而CountDownLatch则是由同步控制器AQS（AbstractQueuedSynchronizer）来实现的
▪ 在构造CyclicBarrier时不允许parties为0，而CountDownLatch则允许count为0。</pre>

## Exchanger
> leftSide=`true`

- NOTE
<pre>Exchanger是Java并发包中的一个工具类。通过exchange方法相互交换数据，
如果第一个线程执行到exchange方法，会等待第二个线程执行exchange，当两个线程都到达时，
会进行数据交换。

▪ public V exchange(V x) throws InterruptedException：数据交换方法，
该方法的作用是将数据x交换至搭档线程，执行该方法后，当前线程会进入阻塞状态，
只有当搭档线程也执行了exchange方法之后，该当前线程才会退出阻塞状态进行下一步的工作，
与此同时，该方法的返回值代表着搭档线程所传递过来的交换数据。
▪ public V exchange(V x, long timeout, TimeUnit unit) throwsInterruptedException, TimeoutException：
该方法的作用与前者类似，只不过增加了超时的功能，
也就是说在指定的时间内搭档线程没有执行exchange方法，当前线程会退出阻塞，并且返回值为null。

如果使用Exchanger的两个线程，其中一个由于某种原因意外退出，
那么此时另外一个线程将会永远处于阻塞状态，进而导致JVM进程出现假死的情况。
当然使用了超时功能的exchange在设定时间到达时会退出阻塞，
因此在使用Exchanger时中断数据交换线程的操作是非常重要的。</pre>

## Semaphore
- NOTE
<pre>Semaphore（信号量）是一个线程同步工具，主要用于在一个时刻允许多个线程对共享资源进行
并行操作的场景。通常情况下，使用Semaphore的过程实际上是多个线程获取访问共享资源许可证
的过程，下面是Semaphore的内部处理逻辑。
▪ 如果此时Semaphore内部的计数器大于零，
那么线程将可以获得小于该计数器数量的许可证，同时还会导致Semaphore内部的计数器减少所发放的许可证数量。
▪ 如果此时Semaphore内部的计数器等于0，也就是说没有可用的许可证，
那么当前线程有可能会被阻塞（使用tryAcquire方法时不会阻塞）。
▪ 当线程不再使用许可证时，
需要立即将其释放以供其他线程使用，所以建议将许可证的获取以及释放动作写在try..finally语句块中。

虽然Semaphore可以控制多个线程对共享资源进行访问，但是对于共享资源的临界区以及线程安全性，
Semaphore并不会提供任何保证。比如，你有5个线程想要同时操作某个资源，
那么该资源的操作线程安全性则需要额外的实现。
另外，如果采取尝试的方式也就是不阻塞的方式获取许可证，务必要做到对结果的判断，
否则就会出现尝试失败但程序依然去执行对共享资源的操作，这样做的后果也是非常严重的。</pre>

## Phaser
> leftSide=`true`

- NOTE
<pre>CountDownLatch可以很好地控制等待多个线程执行完子任务，但是它有一个缺点，
那就是内部的计数器无法重置，也就是说CountDownLatch属于一次性的，使用结束后就不能再次使用。
CyclicBarrier倒是可以重复使用，但是一旦parties在创建的时候被指定，就无法再改变。
Phaser则取百（两）家之所长于一身引入了两者的特性。
1. register方法
register方法的主要作用是为Phaser新增一个未到达的分片，并且返回Phase（阶段）的编号，
该编号与Phaser当前的Phase（阶段）编号数字是一样的，但是调用该方法时，
有些时候会陷入阻塞之中。比如前一个Phase（阶段）在执行onAdvance方法时耗时较长，
那么此时若有一个新的分片想要通过register方法加入到Phaser中就会陷入阻塞。

2. bulkRegister方法
该方法返回的Phase（阶段）编号同register方法，
但是该方法允许注册零个或者一个以上的分片（Parties）到Phaser，
其实无论是register方法还是bulkRegister方法，背后调用的都是doRegister方法，
因此register方法的特点bulkRegister方法都会具备。

3. arrive和arriveAndAwaitAdvance方法
arrive和arriveAndAwaitAdvance方法都是到达Phaser的下一个Phase（阶段），
前者不会等待其他分片（part），后者则会等待所有未到达的分片（part）到达，除了这个区别以外，
更重要的一个区别在于，arrive方法返回的Phase（阶段）编号为当前的Phase（阶段）编号，原理很好理解，
因为它自身不清楚其他分片（part）是否到达也无须等待其他分片（part）到达下一个Phase（阶段），
因此返回Phaser当前的Phase（阶段）编号即可。
但是无论有没有其他的任务分片到达，调用arriveAndAwaitAdvance方法都会返回下一个Phase（阶段）的编号，
这一点很好理解，不管怎样，当前任务分片到达的肯定是下一个Phase（阶段）。

4. arriveAndDeregister方法
该方法的作用除了到达下一个Phase（阶段）之外，它还会将当前Phaser的分区（parties）数量减少一个。
该方法也是Phaser灵活性的一个体现，即动态减少分区（parties）数量，同时该方法的返回值也是整数类型的数字，
代表着当前Phase（阶段）的编号，如果Phase（阶段）的编号数字为负数，则表明当前的Phaser已经被销毁。

5. awaitAdvance与awaitAdvanceInterruptibly方法
在使用arrive以及arriveAndAwaitAdvance、arriveAndDeregister方法的时候，分片任务会到达某个Phase（阶段），
这几个方法在使用的过程中更多关注的是arrive（到达），而不是关注Phase（阶段）编号，
下面将要介绍的三个方法则不会关注arrive（到达）而是在于等待，它们等待某个Phaser关联的所有分片（part）是否已经到达某个指定的Phase（阶段），
同时需要注意的是，在使用这几个方法时，是不会影响Phaser内部分片（part）arrive以及unarrive的变化的。
▪ awaitAdvance(int phase): 该方法的主要作用是等待与Phaser关联的分片（part）都到达某个指定的Phase（阶段）编号，
如果有某个分片任务未到达，那么该方法会进入阻塞状态，这有点类似于CountDownLatch的await方法，
虽然该方法是Phaser提供的方法，但是它并不会参与对arrive与unarrive分片（part）的运算和维护，
如果入参phase与当前Phaser的phase（阶段）编号不一致，则会立即返回，如果当前的Phaser已经被销毁，
那么它同样不会工作，并且调用该方法的返回值为负数。传递了错误的phase编号awaitAdvance方法并不会抛出错误，
因此在使用的时候一定要注意，如果某个phase（阶段）所有的关联分片任务都没有到达，
那么此刻调用awaitAdvance方法的线程将会陷入阻塞状态，并且还会无法对其执行中断操作。
▪ awaitAdvanceInterruptibly(int phase): 该方法的作用与前一个方法一致，但是增加了可被中断的功能。
▪ awaitAdvanceInterruptibly(int phase, long timeout, TimeUnitunit): 该方法同上，除了增加了可被中断的功能之外，还具备超时的功能，
这就需要我们在调用的时候对超时时间进行设置了。

Phaser层级关系
Thread中存在着一定的层级关系，也就是说某一个Thread类会有一个父Thread，
同样在定义Phaser的时候也可以为其指定父Phaser，当我们在创建某个Phaser的时候若指定了父Phaser，
那么它将具有如下这些特性：
▪ 子Phaser当前的Phase（阶段）编号会以父Phaser的编号为准。
▪ 父Phaser的所有分片数量=父Phaser分片数量的自身注册数量+所有子Phaser的分片注册数量之和。
▪ 调用当前Phaser的arriveAndAwaitAdvance方法时，首先会调用父Phaser的对应方法。
▪ 直接调用子Phaser的arrive方法时，在某些情况下会出现bad arrive的错误。
通常情况下，我们不会借助有层级关系的Phaser去实现多线程任务的同步管理，因为这样可能会导致多线程的控制复杂化。


</pre>

## Lock及ReentrantLock
- NOTE
<pre>1. Lock接口方法
Lock接口是对锁操作方法的一个基本定义，它提供了synchronized关键字所具备的全部功能方法，
另外我们可以借助于Lock创建不同的Condition对象进行多线程间的通信操作，
与关键字synchronized进行方法同步代码块同步的方式不同，Lock提供了编程式的锁获取（lock()）
以及释放操作(unlock())等其他操作。
▪ lock()方法：尝试获取锁，如果此刻该锁未被其他线程持有，则会立即返回，
并且设置锁的hold计数为1；如果当前线程已经持有该锁则会再次尝试申请，hold计数将会增加一个，
并且立即返回；如果该锁当前被另外一个线程持有，那么当前线程会进入阻塞，直到获取该锁，
由于调用lock方法而进入阻塞状态的线程同样不会被中断，这一点与进入synchronized同步方法或
者代码块被阻塞类似。
▪ lockInterruptibly()方法：该方法的作用与前者类似，但是使用该方法试图获取锁而进入阻塞操作的
线程则是可被中断的，也就说线程可以获得中断信号。
▪ tryLock()方法：调用该方法获取锁，无论成功与否都会立即返回，线程不会进入阻塞状态，
若成功获取锁则返回true，若获取锁失败则返回false。使用该方法时请务必注意进行结果的判断，
否则会出现获取锁失败却仍旧操作共享资源而导致数据不一致等问题的出现。
▪ tryLock(long time, TimeUnit unit)方法：该方法与tryLock()方法类似，只不过多了单位时间设置，
如果在单位时间内未获取到锁，则返回结果为false，如果在单位时间内获取到了锁，
则返回结果为true，同样hold计数也会被设置为1。
▪ unlock()方法：当某个线程对锁的使用结束之后，应该确保对锁资源的释放，以便其他线程能够继续争抢，unlock()方法的作用正在于此。
▪ newCondition()方法：创建一个与该lock相关联的Condition对象。

2. ReentrantLock扩展方法
在显式锁Lock接口的诸多实现中，我们用得最多的就是ReentrantLock，该类不仅完全实现了显示锁Lock接口所定义的接口，也扩展了对使用显式锁Lock的一些监控方法。
▪ getHoldCount()方法：查询当前线程在某个Lock上的数量，如果当前线程成功获取了Lock，那么该值大于等于1；
如果没有获取到Lock的线程调用该方法，则返回值为0。
▪ isHeldByCurrentThread()方法：判断当前线程是否持有某个Lock，由于Lock的排他性，
因此在某个时刻只有一个线程调用该方法返回true。
▪ isLocked()方法：判断Lock是否已经被线程持有。
▪ isFair()方法：创建的ReentrantLock是否为公平锁。
▪ hasQueuedThreads()方法：在多个线程试图获取Lock的时候，只有一个线程能够正常获得，
其他线程可能（如果使用tryLock()方法失败则不会进入阻塞）会进入阻塞，该方法的作用就是查询是否有线程正在等待获取锁。
▪ hasQueuedThread(Thread thread)方法：在等待获取锁的线程中是否包含某个指定的线程。
▪ getQueueLength()方法：返回当前有多少个线程正在等待获取锁。

3.正确使用显式锁Lock
（1）确保已获取锁的释放
使用synchronized关键字进行共享资源的同步时，JVM提供了两个指令monitor enter和monitor exit来分别确保锁的获取和释放操作，
这与显式锁Lock的lock和unlock方法的作用是一致的。使用try...finally语句块可以确保获取到的lock将被正确释放。
lock和synchronized关键字一样都具备可重入性，lock的内部维护了hold计数器，
而synchronized的内部则维护了monitor计数器，它们的作用都是一样的，若成功获取锁的初始值为1，
那么持有该锁时再次获取锁除了会立即成功之外，对应的计数器也会随之自增，在使用synchronized关键字的时候，
JVM会为我们担保这一切，但是显式锁的使用则需要程序员自行控制。
（2）避免锁的交叉使用引起死锁
交叉使用关键字synchronized可能会引起死锁的情况发生，同样，在使用lock锁的时候也会出现类似的情况。
（3）多个原子性方法的组合不能确保原子性
无论是synchronized关键字还是lock锁，其主要作用之一都是保证若干代码指令的原子操作，
要么都成功要么都失败，也就是说在代码指令的运行过程中不允许被中断，
但是多个原子性方法的组合就无法担保原子性了，无论是使用同一个lock对象还是不同的lock对象。






</pre>

## ReadWriteLock&ReentrantReadWriteLock
> leftSide=`true`

- NOTE
<pre>对共享资源的访问一般包括两种类型的动作，读和写（修改、删除等会引起资源发生变化的动作），
当多个线程同时对某个共享资源进行读取操作时，并不会引起共享资源数据不一致情况的发生
，因此这个时候如果仍旧让资源的访问互斥，就会显得有些不合情理了，
Doug Lea在JDK 1.5版本引入了读写锁类，旨在允许某个特定时刻多线程并发读取共享资源，
提高系统性能和访问吞吐量。
同一个读写锁创建的读锁与写锁，如果一个线程用写锁进行了锁定，那么另一个线程用读锁或写锁进行
锁定都会被阻塞；如果一个线程用读锁进行了锁定，那么另一个线程用写锁进行锁定会被阻塞，但是
用读锁进行锁定则不会被阻塞。

读写锁提供了非常好的思路和解决方案，旨在提高某个时刻都为读操作的并发吞吐量，
但是从基准测试的结果来看性能不尽如人意，因此在JDK1.8版本中引入了StampedLock的解决方案。</pre>

## Condition
- NOTE
<pre>如果说显式锁Lock可以用来替代synchronized关键字，那么Condition接口将会很好地替代传统的、
通过对象监视器调用wait()、notify()、notifyAll()线程间的通信方式。
Condition对象是由某个显式锁Lock创建的，一个显式锁Lock可以创建多个Condition对象与之关联，
Condition的作用在于控制锁并且判断某个条件（临界值）是否满足，如果不满足，
那么使用该锁的线程将会被挂起等待另外的线程将其唤醒，与此同时被挂起的线程将会进入阻塞队列
中并且释放对显式锁Lock的持有，这一点与对象监视器的wait()方法非常类似。

▪ void await() throws InterruptedException：
当前线程调用该方法会进入阻塞状态直到有其他线程对其进行唤醒，或者对当前线程执行中断操作。
当线程执行了await()方法进入阻塞时；当前线程会被加入到阻塞队列中，并且释放对显式锁的持有，
object monitor的wait()方法被执行后同样会加入一个虚拟的容器waitset（线程休息室）中，
waitset是一个虚拟的概念，JVM（虚拟机）规范并未强制要求其采用什么样的数据结构，
Condition的wait队列则是由Java程序实现的FiFO队列。
▪ void awaitUninterruptibly()：该方法与await()方法类似，只不过该方法比较固执，
它会忽略对它的中断操作，一直等待有其他线程将它唤醒。
▪ long awaitNanos(long nanosTimeout) throws InterruptedException：
调用该方法同样会使得当前线程进入阻塞状态，但是可以设定阻塞的最大等待时间，
如果在设定的时间内没有其他线程将它唤醒或者被执行中断操作，
那么当前线程将会等到设定的纳秒时间后退出阻塞状态。
▪ boolean await(long time, TimeUnit unit) throwsInterruptedException：
执行方法awaitNanos(),如果到达设定的纳秒数则当前线程会退出阻塞，并且返回实际等待的纳秒数，
但是程序很难判断线程是否被正常唤醒，因此该方法的作用除了可以指定等待的最大的单位时间，
另外，还可以返回在单位时间内被正常唤醒而且还是由于超时而退出的阻塞。
▪ boolean awaitUntil(Date deadline) throws InterruptedException：
调用该方法同样会导致当前线程进入阻塞状态直到被唤醒、被中断或者到达指定的Date。
▪ void signal()：唤醒Condition阻塞队列中的一个线程，Condition的wait队列采用FiFO的方式，
因此在wait队列中，第一个进入阻塞队列的线程将会被首先唤醒。
▪ void signalAll()：唤醒Condition wait队列中的所有线程。

▪ hasWaiters(Condition condition): 该方法的作用是查询是否有线程由于执行了await方法而进入了
与condition关联的wait 队列之中，若有线程在wait队列中则返回true，否则返回false。
▪ getWaitQueueLength(Condition condition):该方法的作用是查询与condition关联的wait队列数量。
上面这两个方法比较简单，但是使用它们的前提是必须获得对显式锁Lock的持有，
否则将会出现IllegalMonitorStateException异常。



</pre>

## StampedLock
> leftSide=`true`

- NOTE
<pre>JDK1.8版本引入了StampedLock，该锁由一个long型的数据戳（stamp）和三种模型构成，
当获取锁（比如调用readLock()，writeLock()）的时候会返回一个long型的数据戳（stamp），
该数据戳将被用于进行稍后的锁释放参数。如果返回的数据戳为0（比如调用tryWriteLock()），
则表示获取锁失败，同时StampedLock还提供了一种乐观读的操作方式。

需要注意的一点是，StampedLock是不可重入的，不像之前介绍的两种锁类型（ReentrantLock、
ReentrantReadWriteLock）都有hold计数器，每一次对StampedLock锁的获取都会生成一个数据戳，
即使当前线程在获得了该锁的情况下再次获取也会返回一个全新的数据戳，
因此如果使用不当则会出现死锁的问题。

StampedLock被JDK1.8版本引入之后，成为了Lock家族的新宠，它几乎具备了ReentrantLock、
ReentrantReadWriteLock这两种类型锁的所有功能（性能表现要看不同的使用场景）。

作为开发人员要能够根据应用程序的特点来判断应该采用怎样的锁进行贡献资源数据的同步，
以确保数据的一致性，如果你无法明确地了解读写线程的分布情况，那么请使用ReentrantLock，
因为通过基准测试不难发现，它的表现始终非常稳定，无论是读线程还是写线程。
如果你的应用程序中，读操作远远多于写操作，那么为了提高数据读取的并发量，
StampedLock的乐观读将是一个不错的选择，同时它又不会引起饥饿写的问题。</pre>

### 读写锁的饥饿写问题
- NOTE
<pre>我们通过基准测试发现读写锁的性能并不是最佳的，当然更有甚者，如果对读写锁使用不得当，
则还会引起饥饿写的情况发生，那么什么是饥饿写呢？所谓的饥饿写是指在使用读写锁的时候，
读线程的数量远远大于写线程的数量，导致锁长期被读线程霸占，写线程无法获得对数据进行写操作
的权限从而进入饥饿的状态（当然可以在构造读写锁时指定其为公平锁，读写线程获得执行权限得到
的机会相对公平，但是当读线程大于写线程时，性能效率会比较低下）。
因此在使用读写锁进行数据一致性保护时请务必做好线程数量的评估（包括线程操作的任务类型）。
StampedLock可以解决读写锁中“饥饿写”的问题(通过StampedLock的乐观读模式)。</pre>

## Guava
- NOTE
<pre>除了Java自身版本的升级会为开发者提供一些比较好用的并发工具以外，某些第三方类库也提供了
一些很好用的并发工具。比如Google的Guava。</pre>

### Monitor及Guard
- NOTE
<pre>无论使用对象监视器的wait notify/notifyAll还是Condition的await signal/signalAll方法调用，
我们首先都会对共享数据的临界值进行判断，当条件满足或者不满足的时候才会调用相关方法使得
当前线程挂起，或者唤醒wait队列/set中的线程，因此对共享数据临界值的判断非常关键，
Guava的Monitor工具提供了一种将临界值判断抽取成Guard的处理方式，
可以很方便地定义若干个Guard也就是临界值的判断，以及对临界值判断的重复使用，
除此之外Monitor还具备synchronized关键字和显式锁Lock的完整语义。

除了在MonitorTest中使用过的enterWhen()方法之外，Monitor还提供了非常多的使用方法。
▪ enter()：该方法完全等价于Lock的lock()方法。
▪ enterIf(Guard guard)：该方法主要用于判断当前的Guard是否满足临界值的判断，
也是使用比较多的一个操作，调用该方法，当前线程并不会进入阻塞之中。
▪ tryEnter()：等价于Lock的tryLock()方法。
▪ waitFor(Guard guard)：当前线程将会阻塞等待，直到Guard的条件满足当前线程才会退出阻塞状态。</pre>

### RateLimiter
- NOTE
<pre>RateLimiter，顾名思义就是速率（Rate）限流器（Limiter），事实上它的作用正如名字描述的那样，
经常用于进行流量、访问等的限制，这一点与Semaphore非常类似，
但是它们的关注点却完全不同，RateLimiter关注的是在单位时间里对资源的操作速率
（在RateLimiter内部也存在许可证（permits）的概念，因此可以理解为在单位时间内允许颁发的
许可证数量），而Semaphore则关注的是最多允许多少个许可证可被使用，它不关心速率而只关心个数。

RateLimiter的功能非常强大，比如，要想开发一个程序向数据库中写入数据的条目、
向中间件服务器中发送的消息个数、对某个远程TCP端口发送的字节数等，
若这些操作的速率无法被控制，则可能会引起数据库拒绝服务、中间件宕机、
TCP服务端口无法响应等问题，而借助于RateLimiter就可以很好地帮助我们进行匀速的控制。

虽然说RateLimiter主要是用于控制速率的，但是在其内部也有许可证（permits）的概念，
你甚至可以将其理解为单位时间内颁发的许可证数量，RateLimiter不仅允许每次获取一个
许可证的操作，还允许获取超出剩余许可证数量的行为，只不过后者的操作将使得下一次请求为
提前的透支付出代价。</pre>

#### 漏桶算法
- NOTE
<pre>在一个提供高并发服务的系统中，若系统无法承受更多的请求，则对其进行降权处理（直接拒绝请求，
或者将请求暂存起来等稍后处理），这是一种比较常见的做法，漏桶算法作为一种常见的限流算法
应用非常广泛。

漏桶算法的原理
▪ 无论漏桶进水速率如何，漏桶的出水速率永远都是固定的。
▪ 如果漏桶中没有水流，则在出水口不会有水流出。
▪ 漏桶有一定的水容量。
▪ 如果流入水量超过漏桶容量，则水将会溢出（降权处理）。</pre>

#### 令牌环桶算法
- NOTE
<pre>令牌环桶与漏桶比较类似，漏桶对水流进入的速度不做任何限制，它只对水流出去的速率是有严格控制
的，令牌环桶则与之相反，在对某个资源或者方法进行调用之前首先要获取到令牌也就是获取到许
可证才能进行相关的操作，否则将不被允许。比如，常见的互联网秒杀抢购等活动，
商品的数量是有限的，为了防止大量的并发流量进入系统后台导致普通商品消费出现影响，
我们需要对类似这样的操作增加令牌授权、许可放行等操作，这就是所谓的令牌环桶。
过程如下：
▪ 根据固定的速率向桶里提交数据。
▪ 新加数据时如果超过了桶的容量，则请求将会被直接拒绝。
▪ 如果令牌不足，则请求也会被拒绝（请求可以再次尝试）。</pre>

##  LockSupport
> leftSide=`true`

- NOTE
<pre>JDK中的rt.jar包里面的LockSupport是个工具类，它的主要作用是挂起和唤醒线程，
该工具类是创建锁和其他同步类的基础。LockSupport类与每个使用它的线程都会关联一个许可证，
在默认情况下调用LockSupport类的方法的线程是不持有许可证的。LockSupport是使用Unsafe类实现的。

1．void park()方法
如果调用park方法的线程已经拿到了与LockSupport关联的许可证，则调用LockSupport.park（）时会马上返回，
否则调用线程会被禁止参与线程的调度，也就是会被阻塞挂起。
在其他线程调用unpark（Thread thread）方法并且将当前线程作为参数时，
调用park方法而被阻塞的线程会返回。另外，如果其他线程调用了阻塞线程的interrupt（）方法，
设置了中断标志或者线程被虚假唤醒，则阻塞线程也会返回。
所以在调用park方法时最好也使用循环条件判断方式。
需要注意的是，因调用park（）方法而被阻塞的线程被其他线程中断而返回时并不会抛出InterruptedException异常。

2．void unpark(Thread thread)方法
当一个线程调用unpark时，如果参数thread线程没有持有thread与LockSupport类关联的许可证，
则让thread线程持有。如果thread之前因调用park（）而被挂起，则调用unpark后，该线程会被唤醒。如果thread之前没有调用park，则调用unpark方法后，再调用park方法，其会立刻返回。

3．void parkNanos(long nanos)方法
和park方法类似，如果调用park方法的线程已经拿到了与LockSupport关联的许可证，
则调用LockSupport.parkNanos（long nanos）方法后会马上返回。该方法的不同在于，
如果没有拿到许可证，则调用线程会被挂起nanos时间后修改为自动返回。

4.   void park（Object blocker）方法
另外park方法还支持带有blocker参数的方法void park（Object blocker）方法，
当线程在没有持有许可证的情况下调用park方法而被阻塞挂起时，这个blocker对象会被记录到该
线程内部。使用诊断工具可以观察线程被阻塞的原因，诊断工具是通过调用getBlocker（Thread）
方法来获取blocker对象的，所以JDK推荐我们使用带有blocker参数的park方法，并且blocker被
设置为this，这样当在打印线程堆栈排查问题时就能知道是哪个类被阻塞了。
可以通过jstack pid命令来查看有或没有blocker时线程栈的情况。

5．void parkNanos(Object blocker, long nanos)方法
相比park（Object blocker）方法多了个超时时间。

6．void parkUntil(Object blocker, long deadline)方法
其中参数deadline的时间单位为ms，该时间是从1970年到现在某一个时间点的毫秒值。
这个方法和parkNanos（Object blocker, long nanos）方法的区别是，
后者是从当前算等待nanos秒时间，而前者是指定一个时间点，比如需要等到2017.12.11日12:00:00，
则把这个时间点转换为从1970年到这个时间点的总毫秒数。</pre>
