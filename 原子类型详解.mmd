Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# Atomic
- NOTE
<pre>关键字volatile，无论是基本数据类型还是引用类型的变量，只要被volatile关键字修饰，
从JMM（Java Memory Model）的角度分析，该变量就具备了有序性和可见性这两个语义特质，
但是它还是无法保证原子性。那么，什么是原子性呢？
原子性是指某个操作或者一系列操作要么都成功，要么都失败，
不允许出现因中断而导致的部分成功或部分失败的情况。</pre>

##  AtomicInteger

## AtomicBoolean
> leftSide=`true`

- NOTE
<pre>AtomicBoolean提供了一种原子性地读写布尔类型变量的解决方案，
通常情况下，该类将被用于原子性地更新状态标识位，比如flag。
例子见：TryLock</pre>

## AtomicLong
> leftSide=`true`

- NOTE
<pre>在AtomicLong类中最为关键的方法是compareAndSwapLong。
在unsafe.cpp中，compareAndSwapLong方法多了条件编译SUPPORTS_NATIVE_CX8。
SUPPORTS_NATIVE_CX8主要用于判断机器硬件是否支持8字节数字的cmpxchg CPU指令，
如果机器硬件不支持，比如32位的CPU肯定不支持8字节64位数字的cmpxchg CPU指令，
那么此时就需要判断当前JVM版本是否支持8字节数字的cmpxchg操作；
如果机器硬件与当前JVM的版本都不支持，那么实际上针对long型数据的原子性操作将不会是Lock Free的，
对它的原子性保证将由synchronized关键字来承担。

例子VMSupportLongCAS用于判断自己机器上安装的JDK是否支持8字节数字（长整型）的Lock Free CAS操作。</pre>

## AtomicReference
- NOTE
<pre>AtomicReference类提供了对象引用的非阻塞原子性读写操作，并且提供了其他一些高级的用法。
众所周知，对象的引用其实是一个4字节的数字，代表着在JVM堆内存中的引用地址，
对一个4字节数字的读取操作和写入操作本身就是原子性的，通常情况下，
我们对对象引用的操作一般都是获取该引用或者重新赋值（写入操作）。</pre>

## AtomicStampedReference
> leftSide=`true`

- NOTE
<pre>CAS算法，即对比交换算法，是由UNSAFE提供的，实质上是通过操作CPU指令来得到保证的。
CAS算法提供了一种快速失败的方式，当某线程修改已经被改变的数据时会快速失败。
当CAS算法对共享数据操作失败时，因为有自旋算法的加持，我们对共享数据的更新终究会得到计算。
总之，原子类型用自旋+CAS的无锁操作保证了共享变量的线程安全性和原子性。
绝大多数情况下，CAS算法并没有什么问题，但是在需要关心变化值的操作中会存在ABA的问题，
比如一个值原来是A，变成了B，后来又变成了A，那么CAS检查时会发现它的值没有发生变化，
但是实际上却是发生了变化的。

如何避免CAS算法带来的ABA问题呢？针对乐观锁在并发情况下的操作，我们通常会增加版本号，
比如数据库中关于乐观锁的实现方式，以此来解决并发操作带来的ABA问题。
在Java原子包中也提供了这样的实现AtomicStampedReference&lt;E&gt;。
AtomicStampedReference在构建的时候需要一个类似于版本号的int类型变量stamped，
每一次针对共享数据的变化都会导致该stamped的增加（stamped的自增维护需要应用程序自身去负责，AtomicStampedReference并不提供），
因此就可以避免ABA问题的出现。
</pre>

## AtomicArray
- NOTE
<pre>AtomicIntegerArray：提供了原子性操作int数据类型数组元素的操作。
AtomicLongArray：提供了原子性操作long数据类型数组元素的操作。
AtomicReferenceArray：提供了原子性操作对象引用数组元素的操作。</pre>

## AtomicFieldUpdater
> leftSide=`true`

- NOTE
<pre>截至目前我们已经知道，要想使得共享数据的操作具备原子性，目前有两种方案，
第一，使用关键字synchronized进行加锁；
第二，将对应的共享数据定义成原子类型，比如将Int定义成AtomicInteger，
其他数据类型则没有与之直接对应的原子类型，我们可以借助于AtomicReference进行封装。
前者提供了互斥的机制来保证在同一时刻只能有一个线程对共享数据进行操作，
所以说它是一种悲观的同步方式；后者采用CAS算法提供的Lock Free方式，
允许多个线程同时进行共享数据的操作，相比较synchronized关键字，
原子类型提供了乐观的同步解决方案。但是如果你既不想使用synchronized对共享数据的操作进行同步，
又不想将数据类型声明成原子类型的，那么这个时候应该如何进行操作呢？
不用担心，在Java的原子包中提供了原子性操作对象属性的解决方案。
在该解决方案中，开发者无须使用synchronized关键字对共享数据的操作进行同步，
也无须将对应的数据类型声明成原子类型。
在Java的原子包中提供了三种原子性更新对象属性的类，分别如下所示。
▪ AtomicIntegerFieldUpdater：原子性地更新对象的int类型属性，该属性无须被声明成AtomicInteger。
▪ AtomicLongFieldUpdater：原子性地更新对象的long类型属性，该属性无须被声明成AtomicLong。
▪ AtomicReferenceFieldUpdater：原子性地更新对象的引用类型属性，该属性无须被声明成AtomicReference&lt;T&gt;。

AtomicFieldUpdater在使用上非常简单，其内部实现原理也是很容易理解的，
但是并不是所有的成员属性都适合被原子性地更新。
（1）未被volatile关键字修饰的成员属性无法被原子性地更新
（2）类变量无法被原子性地更新
（3）无法直接访问的成员属性不支持原子性地更新
（4）final修饰的成员属性无法被原子性地更新
（5）父类的成员属性无法被原子性地更新

一般在什么情况下，我们才会使用这样的方式为成员属性提供原子性的操作呢？
比如，使用的第三方类库某个属性不是被原子性修饰的，在多线程的环境中若不想通过加锁的方式则可以采用这种方式
（当然这对第三方类库的成员属性要求是比较苛刻的，最起码得满足可被原子性更新的所有条件），
另外，AtomicFieldUpdater的方式相比较直接使用原子类型更加节省应用程序的内存。</pre>

## sun\.misc\.Unsafe详解
- NOTE
<pre>Java是一种安全的开发语言，Java的设计者在设计之初就想将一些危险的操作屏蔽掉。
比如对内存的手动管理，但是本章所学习的原子类型，甚至在接下来的章节中将要学习到的并发工具、
并发容器等在其底层都依赖于一个特殊的类sun.misc.Unsafe，该类是可以直接对内存进行相关操作的，
甚至还可以通过汇编指令直接进行CPU的操作。sun.misc.Unsafe提供了非常多的底层操作方法，
这些方法更加接近机器硬件（CPU/内存），因此效率会更高。
不仅Java本身提供的很多API都对其有严重依赖，而且很多优秀的第三方库/框架都对它有着严重的依赖，
比如LMAXDisruptor，不熟悉系统底层，不熟悉C/C++汇编等的开发者没有必要对它进行深究，
但是这并不妨碍我们直接使用它。在使用的过程中，如果使用不得当，那么代价将是非常高昂的，
因此该类被命名为Unsafe也就在情理之中了，总之一句话，你可以用，但请慎用！

借助于Unsafe可以实现哪些功能呢？
1. 绕过类构造函数完成对象创建
2. 直接修改内存数据
3. 类的加载</pre>
