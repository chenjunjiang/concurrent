Mind Map generated by NB MindMap plugin   
> __version__=`1.1`,showJumps=`true`
---

# 并发容器\(数据结构\)

## BlockingQueue（阻塞队列）
- NOTE
<pre>BlockingQueue是指其中的元素数量存在界限，当队列已满时（队列元素数量达到了最大容量的临界值），
对队列进行写入操作的线程将被阻塞挂起，当队列为空时（队列元素数量达到了为0的临界值），
对队列进行读取的操作线程将被阻塞挂起。实际上，BlockingQueue（LinkedTransferQueue除外）
的内部实现主要依赖于显式锁Lock及其与之关联的Condition。因此涉及的所有BlockingQueue的实现都是线程安全的队列，
在高并发的程序开发中，可以不用担心线程安全的问题而直接使用，另外，BlockingQueue在线程池服务
（ExecutorService）中主要扮演着提供线程对任务存取容器的角色，因此了解每一个BlockingQueue的
使用场景和特点就是本节的主要目的之一。</pre>

### ArrayBlockingQueue
- NOTE
<pre>ArrayBlockingQueue是一个基于数组结构实现的FIFO阻塞队列，在构造该阻塞队列时需要指定队列中
最大元素的数量（容量）。当队列已满时，若再次进行数据写入操作，则线程将会进入阻塞，
一直等待直到其他线程对元素进行消费。当队列为空时，对该队列的消费线程将会进入阻塞，
直到有其他线程写入数据。该阻塞队列中提供了不同形式的读写方法：
1. 阻塞式写方法
在ArrayBlockingQueue中提供了两个阻塞式写方法，分别如下（在该队列中，无论是阻塞式写方法还是非阻塞式写方法，都不允许写入null）。
▪ void put(E e)：向队列的尾部插入新的数据，当队列已满时调用该方法的线程会进入阻塞，
直到有其他线程对该线程执行了中断操作，或者队列中的元素被其他线程消费。
▪ boolean offer(E e, long timeout, TimeUnit unit)：向队列尾部写入新的数据，
当队列已满时执行该方法的线程在指定的时间单位内将进入阻塞，直到到了指定的超时时间后，
或者在此期间有其他线程对队列数据进行了消费。当然了，对由于执行该方法而进入阻塞的线程执行中断
操作也可以使当前线程退出阻塞。该方法的返回值boolean为true时表示写入数据成功，
为false时表示写入数据失败。

2. 非阻塞式写方法
当队列已满时写入数据，如果不想使得当前线程进入阻塞，那么就可以使用非阻塞式的写操作方法。
▪ boolean add(E e)：向队列尾部写入新的数据，当队列已满时不会进入阻塞，但是该方法会抛出队列已满的异常。
▪ boolean offer(E e)：向队列尾部写入新的数据，当队列已满时不会进入阻塞，并且会立即返回false。

3. 阻塞式读方法
ArrayBlockingQueue中提供了两个阻塞式读方法，分别如下。
▪ E take()：从队列头部获取数据，并且该数据会从队列头部移除，当队列为空时执行take方法的线程将进入阻塞，
直到有其他线程写入新的数据，或者当前线程被执行了中断操作。
▪ E poll(long timeout, TimeUnit unit)：从队列头部获取数据并且该数据会从队列头部移除，
如果队列中没有任何元素时则执行该方法，当前线程会阻塞指定的时间，直到在此期间有新的数据写入，
或者阻塞的当前线程被其他线程中断，当线程由于超时退出阻塞时，返回值为null。

4. 非阻塞式读方法
当队列为空时读取数据，如果不想使得当前线程进入阻塞，那么就可以使用非阻塞式的读操作方法。
▪ E poll()：从队列头部获取数据并且该数据会从队列头部移除，当队列为空时，该方法不会使得当前线程进入阻塞，
而是返回null值。
▪ E peek()：peek的操作类似于debug操作（仅仅debug队列头部元素），它直接从队列头部获取一个数据，
但是并不能从队列头部移除数据，当队列为空时，该方法不会使得当前线程进入阻塞，而是返回null值。

</pre>

### PriorityBlockingQueue
- NOTE
<pre>PriorityBlockingQueue优先级阻塞队列是一个“无边界”阻塞队列，该队列会根据某种规则
（Comparator）对插入队列尾部的元素进行排序，因此该队列将不会遵循FIFO
（first-in-first-out）的约束。虽然PriorityBlockingQueue同ArrayBlockingQueue都实现自同样的
接口，拥有同样的方法，但是大多数方法的实现确实具有很大的差别，PriorityBlockingQueue也是
线程安全的类，适用于高并发多线程的情况下。

1. 排序且无边界的队列
只要应用程序的内存足够使用，理论上，PriorityBlockingQueue存放数据的数量是“无边界”的，
在PriorityBlockingQueue内部维护了一个Object的数组，随着数据量的不断增多，
该数组也会进行动态地扩容。在构造PriorityBlockingQueue时虽然提供了一个整数类型的参数，
但是该参数所代表的含义与ArrayBlockingQueue完全不同，前者是构造PriorityBlockingQueue的
初始容量，后者指定的整数类型参数则是ArrayBlockingQueue的最大容量。
根据我们的理解，既然是优先级排序队列，为何在构造PriorityBlockingQueue时并未指定任何数据
排序相关的接口呢？事实上，如果没有显示地指定Comparator，那么它将只支持实现了
Comparable接口的数据类型。比如，Integer类型是Comparable的子类，
因此我们并不需要指定Comparator，默认情况下，优先级最小的数据元素将被放在队列头部，
优先级最大的数据元素将被放在队列尾部。
如果在创建PriorityBlockingQueue队列的时候既没有指定Comparator，同时数据元素也不是
Comparable接口的子类，那么这种情况下，会出现类型转换的运行时异常。

2. 不存在阻塞写方法
由于PriorityBlockingQueue是“无边界”的队列，因此将不存在对队列上限临界值的控制，在PriorityBlockingQueue中，
添加数据元素的所有方法都等价于offer方法，从队列的尾部添加数据，但是该数据会根据排序规则
对数据进行排序。

3. 优先级队列读方法
优先级队列添加元素的方法不存在阻塞（由于是“无边界”的），但是针对优先级队列元素的读方法则与ArrayBlockingQueue类似。

</pre>

### LinkedBlockingQueue
- NOTE
<pre>LinkedBlockingQueue是“可选边界”基于链表实现的FIFO队列。LinkedBlockingQueue队列的边界
可选性是通过构造函数来决定的，当我们在创建LinkedBlockingQueue对象时，使用的是默认的构造
函数，那么该队列的最大容量将为Integer的最大值（所谓的“无边界”），当然开发者可以通过指定
队列最大容量（有边界）的方式创建队列。

LinkedBlockingQueue与ArrayBlockingQueue极其相似。</pre>

### DelayQueue
- NOTE
<pre>DelayQueue也是一个实现了BlockingQueue接口的“无边界”阻塞队列，但是该队列却是非常有意思
和特殊的一个队列（存入DelayQueue中的数据元素会被延迟单位时间后才能消费），
在DelayQueue中，元素也会根据优先级进行排序，这种排序可以是基于数据元素过期时间而进行的
（比如，你可以将最快过期的数据元素排到队列头部，最晚过期的数据元素排到队尾）。
对于存入DelayQueue中的元素是有一定要求的：元素类型必须是Delayed接口的子类，
存入DelayQueue中的元素需要重写getDelay(TimeUnit unit)方法用于计算该元素距离过期的
剩余时间，如果在消费DelayQueue时发现并没有任何一个元素到达过期时间，那么对该队列的读取
操作会立即返回null值，或者使得消费线程进入阻塞。

读取DelayQueue中的数据
DelayQueue队列区别于之前的队列，其中之一就是存入该队列的元素必须是Delayed的
子类，除此之外队列中的数据元素会被延迟（Delay）消费，这也正是延迟队列名称的由来。
与PriorityBlockingQueue一样，DelayQueue中有关增加元素的所有方法都等价于offer(E e)，
并不存在针对队列临界值上限的控制，因此也不存在阻塞写的情况（多线程争抢导致的线程阻塞另当别论）
但是对该队列中数据元素的消费（延迟消费）则有别于其他阻塞队列。
▪ remainingCapacity()方法始终返回Integer.MAX_VALUE
▪ peek()：非阻塞读方法，立即返回但并不移除DelayQueue的头部元素，当队列为空时返回null。队列不为空
时，peek方法不会出现延迟，而是立即返回队列头部的元素，但不移除。
▪ poll():非阻塞读方法，当队列为空或者队列头部元素还未到达过期时间时返回值为null，否则将会从队列头部立即将元素移除并返回。
▪ poll(long timeout, TimeUnit unit)：最大阻塞单位时间，当达到阻塞时间后，此刻为空或者队列
头部元素还未达到过期时间时返回值为null，否则将会立即从队列头部将元素移除并返回。
▪ take()：阻塞式的读取方法，该方法会一直阻塞直到队列中有元素，并且队列中的头部元素已达到
过期时间，然后将其从队列中移除并返回。
</pre>

### ArrayBlockingQueue和LinkedBlockingQueue比较
- NOTE
<pre>https://www.cnblogs.com/lianliang/p/5765349.html

相同：
LinkedBlockingQueue和ArrayBlockingQueue都是可阻塞的队列
内部都是使用ReentrantLock和Condition来保证生产和消费的同步；
当队列为空，消费者线程被阻塞；当队列装满，生产者线程被阻塞；
使用Condition的方法来同步和通信：await()和signal()

不同：
1、锁机制不同
　　LinkedBlockingQueue中的锁是分离的，生产者的锁PutLock，消费者的锁takeLock，
而ArrayBlockingQueue生产者和消费者使用的是同一把锁；
2、底层实现机制也不同
　　LinkedBlockingQueue内部维护的是一个链表结构。
在生产和消费的时候，需要创建Node对象进行插入或移除，大批量数据的系统中，
其对于GC的压力会比较大。
而ArrayBlockingQueue内部维护了一个数组，在生产和消费的时候，
是直接将枚举对象插入或移除的，不会产生或销毁任何额外的对象实例。

3、构造时候的区别
　　LinkedBlockingQueue有默认的容量大小为：Integer.MAX_VALUE，
当然也可以传入指定的容量大小，ArrayBlockingQueue在初始化的时候，必须传入一个容量大小的值

4、执行clear()方法
　　LinkedBlockingQueue执行clear方法时，会加上两把锁

 5、统计元素的个数
　　LinkedBlockingQueue中使用了一个AtomicInteger对象来统计元素的个数，ArrayBlockingQueue则使用int类型来统计元素。</pre>

### SynchronousQueue
- NOTE
<pre>SynchronousQueue也是实现自BlockingQueue的一个阻塞队列，每一次对其的写入操作必须等待
（阻塞）其他线程进行对应的移除操作，SynchronousQueue的内部并不会涉及容量、获取size，
就连peek方法的返回值永远都将会是null，除此之外还有更多的方法在SynchronousQueue中也
都未提供对应的支持（列举如下），因此在使用的过程中需要引起注意，否则会使得程序的运行出现
不符合预期的错误。
▪ clear()：清空队列的方法在SynchronousQueue中不起任何作用。
▪ contains(Object o)：永远返回false。
▪ containsAll(Collection&lt;?&gt; c)：等价于c是否为空的判断。
▪ isEmpty()：永远返回true。▪ iterator()：返回一个空的迭代器。
▪ peek()：永远返回null。▪ remainingCapacity()：始终返回0。
▪ remove(Object o)：不做任何删除，并且始终返回false。
▪ removeAll(Collection&lt;?&gt; c)：不做任何删除，始终返回false。
▪ retainAll(Collection&lt;?&gt; c)：始终返回false。
▪ size()：返回值始终为0。
▪ spliterator()：返回一个空的Spliterator。
▪ toArray()及toArray(T[] a)方法同样也不支持。

简单来说，我们可以借助于SynchronousQueue在两个线程间进行线程安全的数据交换，
这一点比较类似于Exchanger工具类。
尽管SynchronousQueue是一个队列，但是它的主要作用在于在两个线程之间进行数据交换，
区别于Exchanger的主要地方在于（站在使用的角度）SynchronousQueue所涉及的一对线程一个
更加专注于数据的生产，另一个更加专注于数据的消费（各司其职），而Exchanger则更加强调一
对线程数据的交换。Exchanger可以看作一个双向的SynchronousQueue。
</pre>

### LinkedBlockingDeque
- NOTE
<pre>LinkedBlockingDeque是一个基于链表实现的双向（Double EndedQueue，Deque）阻塞队列，
双向队列支持在队尾写入数据，读取、移除数据；在队头写入数据，读取、移除数据。
LinkedBlockingDeque实现自BlockingDeque（BlockingDeque又是BlockingQueue的子接口），
并且支持可选“边界”，与LinkedBlockingQueue一样，对边界的指定在构造LinkedBlockingDeque时就已经确定了。</pre>

### LinkedTransferQueue
- NOTE
<pre>TransferQueue是一个继承了BlockingQueue的接口，并且增加了若干新的方法。
LinkedTransferQueue是TransferQueue接口的实现类，其定义为一个无界的队列，具有FIFO的特性。
1. transfer方法
当某个线程执行了transfer方法后将会进入阻塞，直到有其他线程对transfer的数据元素进行了poll
或者take，否则当前线程会将该数据元素插入队列尾部，并且等待其他线程对其进行消费。
这段文字描述包含了一些非常苛刻的要求，首先，LinkedTransferQueue是一个队列，
是可以存放无限（Integer.MAX_VALUE）数据元素的队列，因此允许同时有多个线程将数据元素
插入队列尾部；其次当线程A通过transfer方法将元素E插入队列尾部时，即使此时此刻有其他线程
也对该队列进行着消费操作，如果元素E未被消费，那么线程A同样也会进入阻塞直到元素E被其他
线程消费。
transfer方法的主要特性，非常类似于SynchronousQueue的put方法，
但是不同于SynchronousQueue的地方在于LinkedTransferQueue存在容量，
允许无限多个数据元素的插入，而前者则不支持。

2. tryTransfer方法与transfer方法不同的是，tryTransfer方法并不会使得执行线程进入阻塞，
如果当前并没有线程等待对元素E的消费（poll或者take），那么执行tryTransfer方法会立即返回失败，
并且元素E也不会插入队列的尾部（transfer不成功），否则返回成功。
tryTransfer还有一个重载方法，支持最大超时时间的设定，在设定的最大超时时间内，
如果没有其他线程对transfer的数据元素进行消费，那么元素E将不会被插入队列尾部，并且退出阻塞，
如果在单位时间内有其他线程消费transfer的元素数据，则元素成功插入队尾并退出阻塞。

3. 其他monitor方法
在TransferQueue中还提供了两个与monitor相关的方法，主要用于获取当前是否有消费者线程在等待消费TransferQueue中的数据。</pre>
